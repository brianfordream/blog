-- MySQL dump 10.13  Distrib 5.5.40, for debian-linux-gnu (x86_64)
--
-- Host: localhost    Database: blog
-- ------------------------------------------------------
-- Server version	5.5.40-0ubuntu0.14.04.1

/*!40101 SET @OLD_CHARACTER_SET_CLIENT=@@CHARACTER_SET_CLIENT */;
/*!40101 SET @OLD_CHARACTER_SET_RESULTS=@@CHARACTER_SET_RESULTS */;
/*!40101 SET @OLD_COLLATION_CONNECTION=@@COLLATION_CONNECTION */;
/*!40101 SET NAMES latin1 */;
/*!40103 SET @OLD_TIME_ZONE=@@TIME_ZONE */;
/*!40103 SET TIME_ZONE='+00:00' */;
/*!40014 SET @OLD_UNIQUE_CHECKS=@@UNIQUE_CHECKS, UNIQUE_CHECKS=0 */;
/*!40014 SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0 */;
/*!40101 SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE='NO_AUTO_VALUE_ON_ZERO' */;
/*!40111 SET @OLD_SQL_NOTES=@@SQL_NOTES, SQL_NOTES=0 */;

--
-- Table structure for table `article`
--

DROP TABLE IF EXISTS `article`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `article` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `title` varchar(256) DEFAULT NULL,
  `content` text,
  `author` varchar(64) DEFAULT NULL,
  `create_time` datetime DEFAULT NULL,
  `category` int(11) DEFAULT NULL,
  PRIMARY KEY (`id`),
  KEY `category` (`category`),
  CONSTRAINT `article_ibfk_1` FOREIGN KEY (`category`) REFERENCES `category` (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=32 DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `article`
--

LOCK TABLES `article` WRITE;
/*!40000 ALTER TABLE `article` DISABLE KEYS */;
INSERT INTO `article` VALUES (6,'寒冬来临，多加件衣裳','<p>今年的秋天格外冷，萧瑟的不仅仅是落叶，更多的是经济形势的下跌。</p>\r\n<p>第一篇博客，就用来纪念这个寒冷的秋天，纪念我那些被伤及到无辜的队友。</p>\r\n<p>人总是需要学会成长，自然生长，和在逆境中成长，经历的都是财富。</p>\r\n<p>我也不知道寒冬会多久，会不会伤到我，但是我知道，只有让自己羽翼丰满，才能抵抗外界的寒冷。</p>\r\n<p>我是程序员，一个有理想的程序员，我要做一个有态度的程序员。</p>\r\n<p>用十个指头，改变哪怕是这个世界的一点点。</p>','努力的Coder','2015-10-25 20:59:00',NULL),(7,'python正则表达式之re.sub','<p>re.sub 用来对字符串进行替换操作</p>\r\n<p>函数原型:re.sub(pattern, repl, string, count=0, flags=0)</p>\r\n<p>pattern:正则表达式，用来查找符合替换条件的子串</p>\r\n<p>repl:替换后的字符，这里repl也可以是一个函数</p>\r\n<p>string:是待替换的字符串</p>\r\n<p>count:默认参数，如果存在多个符合条件的子串时，规定替换字串的个数</p>\r\n<p>flags:用来制定匹配的模式，默认是区分大小写的，所有的flags类型如下：</p>\r\n<pre>I = IGNORECASE = sre_compile.SRE_FLAG_IGNORECASE # ignore case\r\nL = LOCALE = sre_compile.SRE_FLAG_LOCALE # assume current 8-bit locale\r\nU = UNICODE = sre_compile.SRE_FLAG_UNICODE # assume unicode locale\r\nM = MULTILINE = sre_compile.SRE_FLAG_MULTILINE # make anchors look for newline\r\nS = DOTALL = sre_compile.SRE_FLAG_DOTALL # make dot match newline\r\nX = VERBOSE = sre_compile.SRE_FLAG_VERBOSE # ignore whitespace and comments\r\n</pre>\r\n<p>下面这段代码说明了flags的用途：</p>\r\n<pre>Python 2.7.8 (default, Jun 18 2015, 18:54:19) \r\n[GCC 4.9.1] on linux2\r\nType \"help\", \"copyright\", \"credits\" or \"license\" for more information.\r\n&gt;&gt;&gt; import re\r\n&gt;&gt;&gt; title = \"\"\" Hello Java , I like Java \"\"\"\r\n&gt;&gt;&gt; print re.sub(\"Java\", \"Python\" ,title)\r\n Hello Python , I like Python \r\n&gt;&gt;&gt; print re.sub(\"java\", \"Python\" ,title)  #默认flags区分大小写\r\n Hello Java , I like Java \r\n&gt;&gt;&gt; print re.sub(\"java\", \"Python\" ,title, flags=re.IGNORECASE) #设置flags忽略大小写\r\n Hello Python , I like Python \r\n</pre>\r\n<p>sub的第二个参数的强大之处在于不仅可以是一个字符串，例如上面代码中的\"Python\",也可以是一个回调函数，当找到匹配的子串时，会执行回调函数，并将回调函数的返回值作为替换的字符进行替换.回调函数的基本格式如下：</p>\r\n<pre>def parse_image(matched):\r\n        \"\"\"matched代表的就是符合正则表达式的正则表达式对象\"\"\"\r\n        img = matched.group(\'img\')\r\n        alt = matched.group(\'alt\')\r\n        img = img.replace(\'\\\"\', \'\\\'\')\r\n        return \"&lt;img src=\\\"%s\\\" alt=\\\"%s\\\"/&gt;\" % (img, alt)\r\n</pre>\r\n<p>下面给出一个使用回调函数解决实际需求的例子：</p>\r\n<p>在一段文本中，有一些对图片的标记语言，格式定义为|img|img_source|image_alt|</p>\r\n<p>在输出为HTML前，需要对标记语言进行处理，将其转换为标准的HTML标签&lt;img src =\"\" alt =\"\"/&gt;</p>\r\n<p>在文本中有可能存在多处图片标记，处理方法如下：</p>\r\n<pre>image_re = re.compile(r\"\\|img\\|(?P&lt;img&gt;.*?)\\|(?P.*?)\\|\")\r\n\r\ndef parse_image(content):\r\n    \"\"\"\r\n    用来对文本中的图片标签进行处理， 标签-&gt;HTML标记\r\n    |img|image_source|alt|\r\n    \"\"\"\r\n\r\n    def parse(matched):\r\n        img = matched.group(\'img\')\r\n        alt = matched.group(\'alt\')\r\n        img = img.replace(\'\\\"\', \'\\\'\')\r\n        return \"&lt;img src=\\\"%s\\\" alt=\\\"%s\\\"/&gt;\" % (img, alt)\r\n\r\n    return image_re.sub(parse, content)\r\n</pre>\r\n<p>处理过程就是将image source 和image alt在正则表达式中分组并命名，随后定一个回调函数parse,接受一个匹配成功的正则表达式对象，通过这个对象的group方法，可以拿到分组中对应的信息，将这些信息拼接成HTML的ｉｍｇ标签返回即可.</p>','努力的Coder','2015-10-25 23:09:00',5),(8,'Python reload 函数','<p>在运行python程序时，常见的编码错误就是：</p>\r\n<p>&ldquo;UnicodeDecodeError: \'ascii\' codec can\'t decode byte ......&rdquo;</p>\r\n<p>解决编码问题主要就是两个注意的地方：</p>\r\n<p>１．# -*-encoding:utf8-*-</p>\r\n<p>在文件的开头声明代码的编码格式，对于中文注释，print 中文，不加入这个就会报错，类似与：</p>\r\n<p>SyntaxError: Non-ASCII character \'\\xe4\' in file test.py on line 5, but no encoding declared; see http://python.org/dev/peps/pep-0263/ for details</p>\r\n<p>2．重定义解释器的编码格式</p>\r\n<pre>import sys\r\nreload(sys)\r\nsys.setdefaultencoding(\'utf8\')\r\n</pre>\r\n<p>这个方法定义了python解释器对字符串的编码，python2默认使用ASCII进行编码，对汉字以及各种非ASCII码的字符处理时，如果不指定编码格式，就会报错．</p>\r\n<p><code>那么，在上述代码中，为什么需要reload 呢</code></p>\r\n<p>先看一个简单的例子，a.py：</p>\r\n<p><code>print \'a\'</code></p>\r\n<p>b.py</p>\r\n<p><code>import a</code></p>\r\n<p>python b.py的时候会输出　a</p>\r\n<p>修改b.py代码为:</p>\r\n<div class=\"code panel\">\r\n<div class=\"codeContent panelContent\">\r\n<pre class=\"code-java\"><span class=\"code-keyword\">import</span> a\r\n<span class=\"code-keyword\">import</span> a</pre>\r\n</div>\r\n</div>\r\n<p>输出依然为 a,而不是预期的a a</p>\r\n<p>这是因为多次重复使用import 语句时，不会重新加载模块，只是把该模块的内存地址给引用到本地环境变量</p>\r\n<p>为了达到预期的效果，就需要用到reload,它会对已经加载的模块进行重新加载，一般用于原模块有变化的情况，reload的模块之前必须import 过，否则会报错．</p>\r\n<div class=\"code panel\">\r\n<div class=\"codeContent panelContent\">\r\n<pre class=\"code-java\"><span class=\"code-keyword\">import</span> a\r\nreload(a)\r\n<span class=\"code-keyword\">import</span> a</pre>\r\n</div>\r\n</div>\r\n<p>这样就会得到预期的输出</p>\r\n<p>在python处理编码问题时，出现很多的代码就是：</p>\r\n<div class=\"code panel\">\r\n<div class=\"codeContent panelContent\">\r\n<pre class=\"code-java\"><span class=\"code-keyword\">import</span> sys\r\nreload(sys)\r\nsys.setdefaultencoding(<span class=\"code-quote\">\"utf-8\"</span>)\r\n</pre>\r\n</div>\r\n</div>\r\n<p>在这里为啥需要reload呢，如果不reload，会提示没有setdefaultencoding这个方法．原因就在/usr/lib/python2.7/site.py中，有这么一段代码</p>\r\n<div class=\"code panel\">\r\n<div class=\"codeContent panelContent\">\r\n<pre class=\"code-java\">def main():\r\n    global ENABLE_USER_SITE\r\n\r\n     abs__file__()\r\n     known_paths = removeduppaths()\r\n     <span class=\"code-keyword\">if</span> ENABLE_USER_SITE is None:\r\n         ENABLE_USER_SITE = check_enableusersite()\r\n     known_paths = addusersitepackages(known_paths)\r\n     known_paths = addsitepackages(known_paths)\r\n     <span class=\"code-keyword\">if</span> sys.platform == \'os2emx\':\r\n        setBEGINLIBPATH()\r\n     setquit()\r\n     setcopyright()\r\n     sethelper()\r\n     aliasmbcs()\r\n     setencoding()\r\n     execsitecustomize()\r\n     <span class=\"code-keyword\">if</span> ENABLE_USER_SITE:\r\n         execusercustomize()\r\n     # Remove sys.setdefaultencoding() so that users cannot change the\r\n     # encoding after initialization.  The test <span class=\"code-keyword\">for</span> presence is needed when\r\n     # <span class=\"code-keyword\">this</span> module is run as a script, because <span class=\"code-keyword\">this</span> code is executed twice.\r\n     <span class=\"code-keyword\">if</span> hasattr(sys, <span class=\"code-quote\">\"setdefaultencoding\"</span>):\r\n         del sys.setdefaultencoding\r\n\r\n main()\r\n</pre>\r\n</div>\r\n</div>\r\n<p>注意加粗的部分，为了防止用户修改默认编码，　python在调用了这个方法后，就删除了这个方法，当python编译器加载时，会调用这段代码，所以sys中没有setdefaultencoding方法，需要reload重新加载sys模块才可以设置．</p>\r\n<p>此外，python2.7默认使用asci<em>i编码处理程序，同样，site.py中有这样一段代码：</em></p>\r\n<div class=\"code panel\">\r\n<div class=\"codeContent panelContent\">\r\n<pre class=\"code-java\">def setencoding():\r\n     \"\"\"Set the string encoding used by the Unicode implementation.  The\r\n     <span class=\"code-keyword\">default</span> is \'ascii\', but <span class=\"code-keyword\">if</span> you\'re willing to experiment, you can\r\n     change <span class=\"code-keyword\">this</span>.\"\"\"\r\n     encoding = <span class=\"code-quote\">\"ascii\"</span> # Default value set by _PyUnicode_Init()\r\n     <span class=\"code-keyword\">if</span> 0:\r\n         # Enable to support locale aware <span class=\"code-keyword\">default</span> string encodings.\r\n　     <span class=\"code-keyword\">import</span> locale\r\n         loc = locale.getdefaultlocale()\r\n         <span class=\"code-keyword\">if</span> loc[1]:\r\n            encoding = loc[1]\r\n     <span class=\"code-keyword\">if</span> 0:\r\n         # Enable to <span class=\"code-keyword\">switch</span> off string to Unicode coercion and implicit\r\n         # Unicode to string conversion.\r\n        encoding = <span class=\"code-quote\">\"undefined\"</span>\r\n    <span class=\"code-keyword\">if</span> encoding != <span class=\"code-quote\">\"ascii\"</span>:\r\n         # On Non-Unicode builds <span class=\"code-keyword\">this</span> will raise an AttributeError...\r\n        sys.setdefaultencoding(encoding) # Needs Python Unicode build !\r\n</pre>\r\n</div>\r\n</div>\r\n<p>注意加粗的部分，就是python编译器设置默认编码的地方，默认是ascii,如果将这里改为utf-8,基本上各种编码问题就会少很多，当然不推荐改源码的这种做法．</p>','努力的Coder','2015-10-28 22:41:00',5),(9,'Jinja2的模板转义问题','<p>Flask的模板引擎使用的是Jinja2,通过render_template(\'xxx.html\')渲染模板，当模板中有以下代码时：</p>\r\n<div class=\"code panel\">\r\n<div class=\"codeContent panelContent\">\r\n<pre class=\"code-java\">  series: [{% <span class=\"code-keyword\">for</span> item in series%}{\r\n        name: \'{{item.name}}\',\r\n        data: {{item.data}}\r\n    },{% endfor %}]</pre>\r\n</div>\r\n</div>\r\n<p>这里我们需求的item.data 应该是[\'1\',\'2\',\'3\']这种带引号的列表</p>\r\n<p>但通过render_template传过来的item.data会被转义为[%271%27,%272%27,%273%27],单引号会被转义</p>\r\n<p>为了避免这种情况，通过增加&nbsp;<font color=\"#000000\">|safe 可以解决，将上述代码修改为：</font></p>\r\n<div class=\"code panel\">\r\n<div class=\"codeContent panelContent\">\r\n<pre class=\"code-java\">series: [{% <span class=\"code-keyword\">for</span> item in series%}{\r\n        name: \'{{item.name}}\',\r\n        data: {{item.data|safe}}\r\n    },{% endfor %}]</pre>\r\n</div>\r\n</div>\r\n<p><font color=\"#000000\">就可以取消默认的对特殊字符的转义处理</font></p>','努力的Coder','2015-10-28 22:55:00',6),(10,'Jinja2的模板继承','<p><font color=\"#000000\">模板继承是Jinja２中一个非常有用的功能。这个功能允许你创建一个包含有所有公共元素的页面基本骨架，在子模板中可以重用这些公用的元素。&nbsp;</font><br /><font color=\"#000000\">使用模板继承其实很简单，下面我们开始用一个例子来介绍模板继承的用法。&nbsp;</font></p>\r\n<p>先来一个基础模板：base.html</p>\r\n<div class=\"code panel\">\r\n<div class=\"codeContent panelContent\">\r\n<pre class=\"code-java\">&lt;!DOCTYPE html&gt;\r\n&lt;html&gt;\r\n&lt;head lang=<span class=\"code-quote\">\"en\"</span>&gt;\r\n    &lt;meta charset=<span class=\"code-quote\">\"UTF-8\"</span>&gt;\r\n    &lt;link rel=<span class=\"code-quote\">\"stylesheet\"</span> href=<span class=\"code-quote\">\"<span class=\"code-comment\">//cdn.bootcss.com/bootstrap/3.3.5/css/bootstrap.min.css\"</span>&gt;</span>\r\n    &lt;script src=<span class=\"code-quote\">\"<span class=\"code-comment\">//cdn.bootcss.com/jquery/1.11.3/jquery.min.js\"</span>&gt;&lt;/script&gt;</span>\r\n    &lt;script src=<span class=\"code-quote\">\"<span class=\"code-comment\">//cdn.bootcss.com/bootstrap/3.3.5/js/bootstrap.min.js\"</span>&gt;&lt;/script&gt;</span>\r\n    &lt;script type=<span class=\"code-quote\">\"text/javascript\"</span> src=<span class=\"code-quote\">\"/<span class=\"code-keyword\">static</span>/js/highcharts.js\"</span>&gt;&lt;/script&gt;\r\n    &lt;script type=<span class=\"code-quote\">\"text/javascript\"</span> src=<span class=\"code-quote\">\"/<span class=\"code-keyword\">static</span>/js/exporting.js\"</span>&gt;&lt;/script&gt;\r\n&lt;/head&gt;\r\n&lt;body&gt;\r\n{% block body %}<br />This can be override\r\n{% endblock %}\r\n&lt;/body&gt;\r\n&lt;/html&gt;</pre>\r\n</div>\r\n</div>\r\n<p>上面的基础模板引入了共用的js和css</p>\r\n<p>注意：</p>\r\n<div class=\"code panel\">\r\n<div class=\"codeContent panelContent\">\r\n<pre class=\"code-java\">{% block body %}\r\n{% endblock %}</pre>\r\n</div>\r\n</div>\r\n<p>就是告诉Jinja2，这个块中的内容是可以被继承模板替换掉的。</p>\r\n<p>继承模板的示例如下：</p>\r\n<div class=\"code panel\">\r\n<div class=\"codeContent panelContent\">\r\n<pre class=\"code-java\">{% <span class=\"code-keyword\">extends</span> \'base.html\' %}\r\n{% block body %}\r\n&lt;script&gt;\r\n  这是子页面，覆盖掉了父页面的这一部分\r\n{% endblock %}</pre>\r\n</div>\r\n</div>\r\n<p>这段代码由</p>\r\n<div class=\"code panel\">\r\n<div class=\"codeContent panelContent\">\r\n<pre class=\"code-java\">{% <span class=\"code-keyword\">extends</span> \'base.html\' %}</pre>\r\n</div>\r\n</div>\r\n<p>开头，声明集成了base.html这个基础模板</p>\r\n<div class=\"code panel\">\r\n<div class=\"codeContent panelContent\">\r\n<pre class=\"code-java\">{% block body %}\r\nxxx\r\n{% endblock %} </pre>\r\n</div>\r\n</div>\r\n<p>这个块中的内容就将替换掉基础模板中的占位符，生成的新的模板包含了基础模板的所有数据</p>\r\n<p>Jinja2是一个非常强大的模板引擎．</p>','努力的Coder','2015-10-28 23:01:00',6),(11,'改变json.dumps()的输出编码','<p>python中json.dumps可以很方便的将python对象格式化为字符串，使用方法如下：</p>\r\n<p>&gt;&gt;&gt; import json<br />&gt;&gt;&gt; content = \'我很帅，帅的不行不行的\'<br />&gt;&gt;&gt; json.dumps(content)</p>\r\n<p>输入结果是：</p>\r\n<p>\'\"\\\\u6211\\\\u5f88\\\\u5e05\\\\uff0c\\\\u5e05\\\\u7684\\\\u4e0d\\\\u884c\\\\u4e0d\\\\u884c\\\\u7684\"\'</p>\r\n<p>很明显是通过unicode编码的，这样方便了json在不同系统之间的传输，但是，有一些需求，仍然需要utf8这种可见即所得的输出方式，也就是说希望输出人能看懂的数据，通过增加ensure_ascii=False 可以实现，即：json.dumps(&lsquo;中文\',&nbsp;ensure_ascii=False) &nbsp;&nbsp;</p>\r\n<p>&gt;&gt;&gt; print json.dumps(content, ensure_ascii=False)<br />\"我很帅，帅的不行不行的\"</p>','努力的Coder','2015-10-28 23:12:00',5),(12,'Python 获取每个月的总天数','<p>在进行时间处理时，经常会需要得到某个月份的天数，譬如，画折线图时，横坐标是天数的情况下．</p>\r\n<p>获取某年某月的总天数,calendar提供了monthrange函数</p>\r\n<pre><font color=\"#222222\">calendar.monthrange(year, month)</font><br /><font color=\"#222222\">Returns weekday of first day of the month and number of days in month, for the specified year and month.</font></pre>\r\n<p>例子如下：</p>\r\n<pre><font color=\"#222222\">&gt;&gt;&gt; import calendar</font><br /><font color=\"#222222\">&gt;&gt;&gt; now_year=2012</font><br /><font color=\"#222222\">&gt;&gt;&gt; now_month=7</font></pre>\r\n<pre><font color=\"#222222\">&gt;&gt;&gt; calendar.monthrange(now_year,now_month)</font><br /><font color=\"#222222\">(6, 31)</font><br /><font color=\"#222222\">&gt;&gt;&gt; calendar.monthrange(now_year,now_month)[1]</font><br /><font color=\"#222222\">31</font></pre>','努力的Coder','2015-10-28 23:26:00',5),(13,'python re.compile对性能的影响','<div class=\"wiki-content\">\r\n<p>工作中遇到了某个接口请求超时过多，优化代码首先想到的是会不会是因为正则表达式用的太多，re.match出现了很多次，想到了是否能使用正则的预编译re.compile提高效率,对于预编译后的效率，并没有进行实验，而是通过网络搜索，并没有太满意的答案，众说纷纭，后来决定自己做实验来验证结果，使用python命令的timeit参数，timeit可以用来检测某小段代码的执行时间，原理就是通过重复执行并计算平均时间。</p>\r\n<div class=\"code panel\">\r\n<div class=\"codeContent panelContent\">\r\n<pre class=\"code-java\"> python -m timeit -s <span class=\"code-quote\">\"<span class=\"code-keyword\">import</span> re\"</span> <span class=\"code-quote\">\"r=re.compile(r\'hello\')\"</span> <span class=\"code-quote\">\"r.match(\'helloword\')\"</span>\r\n</pre>\r\n</div>\r\n</div>\r\n<p>-s 之后就是python 语句，都是用空格分隔</p>\r\n<p>这个是先编译的正则表达式，随后再进行匹配</p>\r\n<div class=\"code panel\">\r\n<div class=\"codeContent panelContent\">\r\n<pre class=\"code-java\">python -m timeit -s <span class=\"code-quote\">\"<span class=\"code-keyword\">import</span> re\"</span> <span class=\"code-quote\">\"r = re.compile(\'hello\')\"</span> <span class=\"code-quote\">\"r.match(\'hello\',\'helloword\')\"</span>\r\n</pre>\r\n</div>\r\n</div>\r\n<p>而这个就是不进行预编译的语句。</p>\r\n<p>第一个执行的结果是：</p>\r\n<p>1000000 loops, best of 3: 0.804 usec per loop</p>\r\n<p>第二个是：<br />1000000 loops, best of 3: 0.818 usec per loop<br />虽然每次运行时间不太相同，预编译过的一般比不预编译的要快一些，但是提升并不大。</p>\r\n<p>观察源码是因为re.match是：</p>\r\n<div class=\"code panel\">\r\n<div class=\"codeContent panelContent\">\r\n<pre class=\"code-java\">def match(pattern, string, flags=0):\r\n    \"\"\"Try to apply the pattern at the start of the string, returning\r\n    a match object, or None <span class=\"code-keyword\">if</span> no match was found.\"\"\"\r\n    <span class=\"code-keyword\">return</span> _compile(pattern, flags).match(string)</pre>\r\n</div>\r\n</div>\r\n<p>而re.compile是：</p>\r\n<div class=\"code panel\">\r\n<div class=\"codeContent panelContent\">\r\n<pre class=\"code-java\">def compile(pattern, flags=0):\r\n    <span class=\"code-quote\">\"Compile a regular expression pattern, returning a pattern object.\"</span>\r\n    <span class=\"code-keyword\">return</span> _compile(pattern, flags)</pre>\r\n</div>\r\n</div>\r\n<p>而_compile的代码：</p>\r\n<div class=\"code panel\">\r\n<div class=\"codeContent panelContent\">\r\n<pre class=\"code-java\">def _compile(*key):\r\n    # internal: compile pattern\r\n    pattern, flags = key\r\n    bypass_cache = flags &amp; DEBUG\r\n    <span class=\"code-keyword\">if</span> not bypass_cache:\r\n        cachekey = (type(key[0]),) + key\r\n        p = _cache.get(cachekey)\r\n        <span class=\"code-keyword\">if</span> p is not None:\r\n            <span class=\"code-keyword\">return</span> p\r\n    <span class=\"code-keyword\">if</span> isinstance(pattern, _pattern_type):\r\n        <span class=\"code-keyword\">if</span> flags:\r\n            raise ValueError(\'Cannot process flags argument with a compiled pattern\')\r\n        <span class=\"code-keyword\">return</span> pattern\r\n    <span class=\"code-keyword\">if</span> not sre_compile.isstring(pattern):\r\n        raise TypeError, <span class=\"code-quote\">\"first argument must be string or compiled pattern\"</span>\r\n    <span class=\"code-keyword\">try</span>:\r\n        p = sre_compile.compile(pattern, flags)\r\n    except error, v:\r\n        raise error, v # invalid expression\r\n    <span class=\"code-keyword\">if</span> not bypass_cache:\r\n        <span class=\"code-keyword\">if</span> len(_cache) &gt;= _MAXCACHE:\r\n            _cache.clear()\r\n        _cache[cachekey] = p\r\n    <span class=\"code-keyword\">return</span> p</pre>\r\n</div>\r\n</div>\r\n<p>re.match也是先调用了_compile，然后再进行match,与先compile再match是一样的。</p>\r\n<p>而_compile会从模块的缓存中存取正则表达式，这个缓存的大小是100,当正则表达式频繁的变动并超过100时，缓存的作用就降低了，正则的效率也就随之降低．</p>\r\n<p>所以，如果需要频繁的使用少数的正则时，效率会有提升，而正则表达式过多时，缓存带来的优势就不明显了</p>\r\n</div>\r\n<div id=\"labels-section\" class=\"pageSection\">&nbsp;</div>','努力的Coder','2015-10-28 23:36:00',5),(14,'python中if __name__ == \'__main__\' 的作用','<p><font color=\"#4b4b4b\">模块是对象，并且所有的模块都有一个内置属性 _＿</font><font color=\"#4b4b4b\"><em>name__</em></font><font color=\"#4b4b4b\"><em>。一个模块的 __name_</em></font><font color=\"#4b4b4b\">_ 的值取决于您如何应用模块。如果 import 一个模块，那么模块＿_</font><font color=\"#4b4b4b\"><em>name＿</em></font><font color=\"#4b4b4b\">_ 的值通常为模块文件名，不带路径或者文件扩展名。但是您也可以像一个标准的程序样直接运行模块，在这 种情况下, ＿_</font><font color=\"#4b4b4b\"><em>name</em></font><font color=\"#4b4b4b\">_＿ 的值将是一个特别缺省\"_＿</font><font color=\"#4b4b4b\"><em>main</em></font><font color=\"#4b4b4b\">_＿\"。</font></p>\r\n<p><font color=\"#4b4b4b\">例如：test.py内容为：</font></p>\r\n<div class=\"code panel\">\r\n<div class=\"codeContent panelContent\">\r\n<pre class=\"code-java\">class Test:\r\n      print __name__                        </pre>\r\n</div>\r\n</div>\r\n<p>test1.py的内容为：</p>\r\n<div class=\"code panel\">\r\n<div class=\"codeContent panelContent\">\r\n<pre class=\"code-java\"><span class=\"code-keyword\">import</span> test\r\n</pre>\r\n</div>\r\n</div>\r\n<p>直接运行python test.py输出为：_＿<em>main</em>_＿</p>\r\n<p>运行python test1.py输出为：test</p>','努力的Coder','2015-10-28 23:42:00',5),(15,'python装饰器@','<p>装饰器以@开头，接着是装饰器的名字和可选的参数。装饰器的用法类似与Spring中的切片，从本质上来讲，是面向切片编程(AOP)的思想。</p>\r\n<p>使用装饰器可以降低程序的复杂度，方便的进行：</p>\r\n<p>引入日志;</p>\r\n<p>引入时间统计性能;</p>\r\n<p>加入事物</p>\r\n<p>装饰器在python中也是一个函数对象，使用场景是这样的：</p>\r\n<p>对外提供了一个接口，里面有几个方法顺序执行，接口响应时间大概在几十毫秒，但是当请求较多时，接口就容易出现超时，响应时间从几百毫秒到几分钟不等，为了排查问题，找出影响相应速度的到底是哪一个方法，决定统计每个方法的调用时间，这时，就用到了装饰器，也就是AOP的设计思想，实现如下：</p>\r\n<p>首先是装饰器的定义：</p>\r\n<div class=\"code panel\">\r\n<div class=\"codeContent panelContent\">\r\n<pre class=\"code-java\"><span class=\"code-keyword\">import</span> time\r\n<span class=\"code-keyword\">import</span> logging\r\n\r\n# --exeTime\r\ndef exeTime(func):\r\n    def newFunc(*args, **args2):\r\n        t0 = time.time()\r\n        # logging.info(<span class=\"code-quote\">\"@%s, {%s} start\"</span> % (time.strftime(<span class=\"code-quote\">\"%X\"</span>, time.localtime()), func.__name__))\r\n        back = func(*args, **args2)\r\n        #logging.info(<span class=\"code-quote\">\"@%s, {%s} end\"</span> % (time.strftime(<span class=\"code-quote\">\"%X\"</span>, time.localtime()), func.__name__))\r\n        t = (time.time() - t0) * 1000\r\n        <span class=\"code-keyword\">if</span> t &gt; 10.0:\r\n            logging.info(<span class=\"code-quote\">\"@%fms taken <span class=\"code-keyword\">for</span> {%s}\"</span> % ((time.time() - t0) * 1000, func.__name__))\r\n        <span class=\"code-keyword\">return</span> back\r\n\r\n    <span class=\"code-keyword\">return</span> newFunc\r\n\r\n# --end of exeTime</pre>\r\n</div>\r\n</div>\r\n<p>在装饰器中，定义了一个内部函数，这个函数首先记录了一个时间t0,然后调用了被装饰的函数，并记录了函数的执行结果，之后记录了一个时间差，如果执行时间大于10毫秒，则输出到日志文件，方便统计，最后内部函数返回被装饰对象执行的结果。而装饰器则返回内部函数的函数对象的引用</p>\r\n<p>使用方法如下：</p>\r\n<div class=\"code panel\">\r\n<div class=\"codeContent panelContent\">\r\n<pre class=\"code-java\">@exeTime\r\ndef some_function(params):\r\n        do something\r\n</pre>\r\n</div>\r\n</div>\r\n<p>通过类似于java中的注解的形式就可以完成。</p>\r\n<p>这个装饰器在被装饰函数执行的时间超过10ms时，就会在日志中输出一条记录。</p>',' 努力的Coder','2015-10-28 23:46:00',5),(16,'别是一番滋味在心头','<p>去年的这个时候，一群意气风发的少年们来到了北京，刚从学校来到公司，一起学习，一起做项目，真的有种非我独尊的霸气。程序员就是这么的简单，这么的可爱，一起在一起的时光总是那么的短暂，总是在失去是才感叹时光匆匆。虽然总说程序员不可能在一个公司呆一辈子，但是，他们的存在，却让我对公司有了更多的留恋和不舍。虽然总有分别得那天，但不想让它来的那么快。</p>\r\n<p>可是，这个寒冬，让一切都变得脆弱了起来。在宏观上，我们只是渺小的不能再渺小的一颗棋子，分别成了挂载嘴边的一个词语，对于未来的不确定性，让大家更懂得珍惜在一起的每一天。好羡慕爱情公寓里的那种生活，一栋大房子，一大帮好友，吹吹牛逼，扯扯淡，生活的美好也不过如此。</p>\r\n<p>公司的突然合并，让很多人唏嘘不已，就像是一个正在奔跑的巨人在外力的作用下突然被肢解掉了一样，领导们都出来安抚人心，其实，大家都明白，这个我们曾经奋斗过的，热爱过的地方迟早一天会被边缘化，就像曾经被收购的同类型公司一样，大家迟早都得各奔东西，曾经的美好也只能默默的放在心里，这里是我职业生涯的起点，但不会是终点。我爱这里，更爱这里的人。</p>','努力的Coder','2015-11-01 22:13:00',NULL),(17,'An introduction to Redis data types and abstractions','<h3><strong>转自官方文档：http://redis.io/topics/data-types-intro</strong></h3>\r\n<p>Redis is not a <em>plain</em> key-value store, actually it is a <em>data structures server</em>, supporting different kind of values. What this means is that, while in traditional key-value stores you associated string keys to string values, in Redis the value is not limited to a simple string, but can also hold more complex data structures. The following is the list of all the data structures supported by Redis, which will be covered separately in this tutorial:</p>\r\n<ul>\r\n<li>Binary-safe strings.</li>\r\n<li>Lists: collections of string elements sorted according to the order of insertion. They are basically <em>linked lists</em>.</li>\r\n<li>Sets: collections of unique, unsorted string elements.</li>\r\n<li>Sorted sets, similar to Sets but where every string element is associated to a floating number value, called <em>score</em>. The elements are always taken sorted by their score, so unlike Sets it is possible to retrieve a range of elements (for example you may ask: give me the top 10, or the bottom 10).</li>\r\n<li>Hashes, which are maps composed of fields associated with values. Both the field and the value are strings. This is very similar to Ruby or Python hashes.</li>\r\n<li>Bit arrays (or simply bitmaps): it is possible, using special commands, to handle String values like an array of bits: you can set and clear individual bits, count all the bits set to 1, find the first set or unset bit, and so forth.</li>\r\n<li>HyperLogLogs: this is a probabilistic data structure which is used in order to estimate the cardinality of a set. Don\'t be scared, it is simpler than it seems... See later in the HyperLogLog section of this tutorial.</li>\r\n</ul>\r\n<p>It\'s not always trivial to grasp how these data types work and what to use in order to solve a given problem from the<a href=\"http://redis.io/commands\">command reference</a>, so this document is a crash course to Redis data types and their most common patterns.</p>\r\n<p>For all the examples we\'ll use the <code>redis-cli</code> utility, that\'s a simple but handy command line utility to issue commands against the Redis server.</p>\r\n<h2>Redis keys</h2>\r\n<p>Redis keys are binary safe, this means that you can use any binary sequence as a key, from a string like \"foo\" to the content of a JPEG file. The empty string is also a valid key.</p>\r\n<p>A few other rules about keys:</p>\r\n<ul>\r\n<li>Very long keys are not a good idea, for instance a key of 1024 bytes is a bad idea not only memory-wise, but also because the lookup of the key in the dataset may require several costly key-comparisons. Even when the task at hand is to match the existence of a large value, to resort to hashing it (for example with SHA1) is a better idea, especially from the point of view of memory and bandwidth.</li>\r\n<li>Very short keys are often not a good idea. There is little point in writing \"u1000flw\" as a key if you can instead write \"user:1000:followers\". The latter is more readable and the added space is minor compared to the space used by the key object itself and the value object. While short keys will obviously consume a bit less memory, your job is to find the right balance.</li>\r\n<li>Try to stick with a schema. For instance \"object-type:id\" is a good idea, as in \"user:1000\". Dots or dashes are often used for multi-word fields, as in \"comment:1234:reply.to\" or \"comment:1234:reply-to\".</li>\r\n<li>The maximum allowed key size is 512 MB.</li>\r\n</ul>\r\n<p><a name=\"strings\"></a></p>\r\n<h2>Redis Strings</h2>\r\n<p>The Redis String type is the simplest type of value you can associate with a Redis key. It is the only data type in Memcached, so it is also very natural for newcomers to use it in Redis.</p>\r\n<p>Since Redis keys are strings, when we use the string type as a value too, we are mapping a string to another string. The string data type is useful for a number of use cases, like caching HTML fragments or pages.</p>\r\n<p>Let\'s play a bit with the string type, using <code>redis-cli</code> (all the examples will be performed via <code>redis-cli</code> in this tutorial).</p>\r\n<pre><code>&gt; set mykey somevalue\r\nOK\r\n&gt; get mykey\r\n\"somevalue\"\r\n</code></pre>\r\n<p>As you can see using the <a href=\"http://redis.io/commands/set\">SET</a> and the <a href=\"http://redis.io/commands/get\">GET</a> commands are the way we set and retrieve a string value. Note that <a href=\"http://redis.io/commands/set\">SET</a> will replace any existing value already stored into the key, in the case that the key already exists, even if the key is associated with a non-string value. So <a href=\"http://redis.io/commands/set\">SET</a> performs an assignment.</p>\r\n<p>Values can be strings (including binary data) of every kind, for instance you can store a jpeg image inside a key. A value can\'t be bigger than 512 MB.</p>\r\n<p>The <a href=\"http://redis.io/commands/set\">SET</a> command has interesting options, that are provided as additional arguments. For example, I may ask <a href=\"http://redis.io/commands/set\">SET</a> to fail if the key already exists, or the opposite, that it only succeed if the key already exists:</p>\r\n<pre><code>&gt; set mykey newval nx\r\n(nil)\r\n&gt; set mykey newval xx\r\nOK\r\n</code></pre>\r\n<p>Even if strings are the basic values of Redis, there are interesting operations you can perform with them. For instance, one is atomic increment:</p>\r\n<pre><code>&gt; set counter 100\r\nOK\r\n&gt; incr counter\r\n(integer) 101\r\n&gt; incr counter\r\n(integer) 102\r\n&gt; incrby counter 50\r\n(integer) 152\r\n</code></pre>\r\n<p>The <a href=\"http://redis.io/commands/incr\">INCR</a> command parses the string value as an integer, increments it by one, and finally sets the obtained value as the new value. There are other similar commands like <a href=\"http://redis.io/commands/incrby\">INCRBY</a>, <a href=\"http://redis.io/commands/decr\">DECR</a> and <a href=\"http://redis.io/commands/decrby\">DECRBY</a>. Internally it\'s always the same command, acting in a slightly different way.</p>\r\n<p>What does it mean that INCR is atomic? That even multiple clients issuing INCR against the same key will never enter into a race condition. For instance, it will never happen that client 1 reads \"10\", client 2 reads \"10\" at the same time, both increment to 11, and set the new value to 11. The final value will always be 12 and the read-increment-set operation is performed while all the other clients are not executing a command at the same time.</p>\r\n<p>There are a number of commands for operating on strings. For example the <a href=\"http://redis.io/commands/getset\">GETSET</a> command sets a key to a new value, returning the old value as the result. You can use this command, for example, if you have a system that increments a Redis key using <a href=\"http://redis.io/commands/incr\">INCR</a> every time your web site receives a new visitor. You may want to collect this information once every hour, without losing a single increment. You can <a href=\"http://redis.io/commands/getset\">GETSET</a> the key, assigning it the new value of \"0\" and reading the old value back.</p>\r\n<p>The ability to set or retrieve the value of multiple keys in a single command is also useful for reduced latency. For this reason there are the <a href=\"http://redis.io/commands/mset\">MSET</a> and <a href=\"http://redis.io/commands/mget\">MGET</a> commands:</p>\r\n<pre><code>&gt; mset a 10 b 20 c 30\r\nOK\r\n&gt; mget a b c\r\n1) \"10\"\r\n2) \"20\"\r\n3) \"30\"\r\n</code></pre>\r\n<p>When <a href=\"http://redis.io/commands/mget\">MGET</a> is used, Redis returns an array of values.</p>\r\n<h2>Altering and querying the key space</h2>\r\n<p>There are commands that are not defined on particular types, but are useful in order to interact with the space of keys, and thus, can be used with keys of any type.</p>\r\n<p>For example the <a href=\"http://redis.io/commands/exists\">EXISTS</a> command returns 1 or 0 to signal if a given key exists or not in the database, while the <a href=\"http://redis.io/commands/del\">DEL</a>command deletes a key and associated value, whatever the value is.</p>\r\n<pre><code>&gt; set mykey hello\r\nOK\r\n&gt; exists mykey\r\n(integer) 1\r\n&gt; del mykey\r\n(integer) 1\r\n&gt; exists mykey\r\n(integer) 0\r\n</code></pre>\r\n<p>From the examples you can also see how <a href=\"http://redis.io/commands/del\">DEL</a> itself returns 1 or 0 depending on whether the key was removed (it existed) or not (there was no such key with that name).</p>\r\n<p>There are many key space related commands, but the above two are the essential ones together with the <a href=\"http://redis.io/commands/type\">TYPE</a>command, which returns the kind of value stored at the specified key:</p>\r\n<pre><code>&gt; set mykey x\r\nOK\r\n&gt; type mykey\r\nstring\r\n&gt; del mykey\r\n(integer) 1\r\n&gt; type mykey\r\nnone\r\n</code></pre>\r\n<h2>Redis expires: keys with limited time to live</h2>\r\n<p>Before continuing with more complex data structures, we need to discuss another feature which works regardless of the value type, and is called <strong>Redis expires</strong>. Basically you can set a timeout for a key, which is a limited time to live. When the time to live elapses, the key is automatically destroyed, exactly as if the user called the <a href=\"http://redis.io/commands/del\">DEL</a> command with the key.</p>\r\n<p>A few quick info about Redis expires:</p>\r\n<ul>\r\n<li>They can be set both using seconds or milliseconds precision.</li>\r\n<li>However the expire time resolution is always 1 millisecond.</li>\r\n<li>Information about expires are replicated and persisted on disk, the time virtually passes when your Redis server remains stopped (this means that Redis saves the date at which a key will expire).</li>\r\n</ul>\r\n<p>Setting an expire is trivial:</p>\r\n<pre><code>&gt; set key some-value\r\nOK\r\n&gt; expire key 5\r\n(integer) 1\r\n&gt; get key (immediately)\r\n\"some-value\"\r\n&gt; get key (after some time)\r\n(nil)\r\n</code></pre>\r\n<p>The key vanished between the two <a href=\"http://redis.io/commands/get\">GET</a> calls, since the second call was delayed more than 5 seconds. In the example above we used <a href=\"http://redis.io/commands/expire\">EXPIRE</a> in order to set the expire (it can also be used in order to set a different expire to a key already having one, like <a href=\"http://redis.io/commands/persist\">PERSIST</a> can be used in order to remove the expire and make the key persistent forever). However we can also create keys with expires using other Redis commands. For example using <a href=\"http://redis.io/commands/set\">SET</a> options:</p>\r\n<pre><code>&gt; set key 100 ex 10\r\nOK\r\n&gt; ttl key\r\n(integer) 9\r\n</code></pre>\r\n<p>The example above sets a key with the string value <code>100</code>, having an expire of ten seconds. Later the <a href=\"http://redis.io/commands/ttl\">TTL</a> command is called in order to check the remaining time to live for the key.</p>\r\n<p>In order to set and check expires in milliseconds, check the <a href=\"http://redis.io/commands/pexpire\">PEXPIRE</a> and the <a href=\"http://redis.io/commands/pttl\">PTTL</a> commands, and the full list of <a href=\"http://redis.io/commands/set\">SET</a>options.</p>\r\n<p><a name=\"lists\"></a></p>\r\n<h2>Redis Lists</h2>\r\n<p>To explain the List data type it\'s better to start with a little bit of theory, as the term <em>List</em> is often used in an improper way by information technology folks. For instance \"Python Lists\" are not what the name may suggest (Linked Lists), but rather Arrays (the same data type is called Array in Ruby actually).</p>\r\n<p>From a very general point of view a List is just a sequence of ordered elements: 10,20,1,2,3 is a list. But the properties of a List implemented using an Array are very different from the properties of a List implemented using a <em>Linked List</em>.</p>\r\n<p>Redis lists are implemented via Linked Lists. This means that even if you have millions of elements inside a list, the operation of adding a new element in the head or in the tail of the list is performed <em>in constant time</em>. The speed of adding a new element with the <a href=\"http://redis.io/commands/lpush\">LPUSH</a> command to the head of a list with ten elements is the same as adding an element to the head of list with 10 million elements.</p>\r\n<p>What\'s the downside? Accessing an element <em>by index</em> is very fast in lists implemented with an Array (constant time indexed access) and not so fast in lists implemented by linked lists (where the operation requires an amount of work proportional to the index of the accessed element).</p>\r\n<p>Redis Lists are implemented with linked lists because for a database system it is crucial to be able to add elements to a very long list in a very fast way. Another strong advantage, as you\'ll see in a moment, is that Redis Lists can be taken at constant length in constant time.</p>\r\n<p>When fast access to the middle of a large collection of elements is important, there is a different data structure that can be used, called sorted sets. Sorted sets will be covered later in this tutorial.</p>\r\n<h2>First steps with Redis Lists</h2>\r\n<p>The <a href=\"http://redis.io/commands/lpush\">LPUSH</a> command adds a new element into a list, on the left (at the head), while the <a href=\"http://redis.io/commands/rpush\">RPUSH</a> command adds a new element into a list ,on the right (at the tail). Finally the <a href=\"http://redis.io/commands/lrange\">LRANGE</a> command extracts ranges of elements from lists:</p>\r\n<pre><code>&gt; rpush mylist A\r\n(integer) 1\r\n&gt; rpush mylist B\r\n(integer) 2\r\n&gt; lpush mylist first\r\n(integer) 3\r\n&gt; lrange mylist 0 -1\r\n1) \"first\"\r\n2) \"A\"\r\n3) \"B\"\r\n</code></pre>\r\n<p>Note that <a href=\"http://redis.io/commands/lrange\">LRANGE</a> takes two indexes, the first and the last element of the range to return. Both the indexes can be negative, telling Redis to start counting from the end: so -1 is the last element, -2 is the penultimate element of the list, and so forth.</p>\r\n<p>As you can see <a href=\"http://redis.io/commands/rpush\">RPUSH</a> appended the elements on the right of the list, while the final <a href=\"http://redis.io/commands/lpush\">LPUSH</a> appended the element on the left.</p>\r\n<p>Both commands are <em>variadic commands</em>, meaning that you are free to push multiple elements into a list in a single call:</p>\r\n<pre><code>&gt; rpush mylist 1 2 3 4 5 \"foo bar\"\r\n(integer) 9\r\n&gt; lrange mylist 0 -1\r\n1) \"first\"\r\n2) \"A\"\r\n3) \"B\"\r\n4) \"1\"\r\n5) \"2\"\r\n6) \"3\"\r\n7) \"4\"\r\n8) \"5\"\r\n9) \"foo bar\"\r\n</code></pre>\r\n<p>An important operation defined on Redis lists is the ability to <em>pop elements</em>. Popping elements is the operation of both retrieving the element from the list, and eliminating it from the list, at the same time. You can pop elements from left and right, similarly to how you can push elements in both sides of the list:</p>\r\n<pre><code>&gt; rpush mylist a b c\r\n(integer) 3\r\n&gt; rpop mylist\r\n\"c\"\r\n&gt; rpop mylist\r\n\"b\"\r\n&gt; rpop mylist\r\n\"a\"\r\n</code></pre>\r\n<p>We added three elements and popped three elements, so at the end of this sequence of commands the list is empty and there are no more elements to pop. If we try to pop yet another element, this is the result we get:</p>\r\n<pre><code>&gt; rpop mylist\r\n(nil)\r\n</code></pre>\r\n<p>Redis returned a NULL value to signal that there are no elements into the list.</p>\r\n<h2>Common use cases for lists</h2>\r\n<p>Lists are useful for a number of tasks, two very representative use cases are the following:</p>\r\n<ul>\r\n<li>Remember the latest updates posted by users into a social network.</li>\r\n<li>Communication between processes, using a consumer-producer pattern where the producer pushes items into a list, and a consumer (usually a <em>worker</em>) consumes those items and executed actions. Redis has special list commands to make this use case both more reliable and efficient.</li>\r\n</ul>\r\n<p>For example both the popular Ruby libraries <a href=\"https://github.com/resque/resque\">resque</a> and <a href=\"https://github.com/mperham/sidekiq\">sidekiq</a> use Redis lists under the hood in order to implement background jobs.</p>\r\n<p>The popular Twitter social network <a href=\"http://www.infoq.com/presentations/Real-Time-Delivery-Twitter\">takes the latest tweets</a> posted by users into Redis lists.</p>\r\n<p>To describe a common use case step by step, imagine your home page shows the latest photos published in a photo sharing social network and you want to speedup access.</p>\r\n<ul>\r\n<li>Every time a user posts a new photo, we add its ID into a list with <a href=\"http://redis.io/commands/lpush\">LPUSH</a>.</li>\r\n<li>When users visit the home page, we use <code>LRANGE 0 9</code> in order to get the latest 10 posted items.</li>\r\n</ul>\r\n<h2>Capped lists</h2>\r\n<p>In many use cases we just want to use lists to store the <em>latest items</em>, whatever they are: social network updates, logs, or anything else.</p>\r\n<p>Redis allows us to use lists as a capped collection, only remembering the latest N items and discarding all the oldest items using the <a href=\"http://redis.io/commands/ltrim\">LTRIM</a> command.</p>\r\n<p>The <a href=\"http://redis.io/commands/ltrim\">LTRIM</a> command is similar to <a href=\"http://redis.io/commands/lrange\">LRANGE</a>, but <strong>instead of displaying the specified range of elements</strong> it sets this range as the new list value. All the elements outside the given range are removed.</p>\r\n<p>An example will make it more clear:</p>\r\n<pre><code>&gt; rpush mylist 1 2 3 4 5\r\n(integer) 5\r\n&gt; ltrim mylist 0 2\r\nOK\r\n&gt; lrange mylist 0 -1\r\n1) \"1\"\r\n2) \"2\"\r\n3) \"3\"\r\n</code></pre>\r\n<p>The above <a href=\"http://redis.io/commands/ltrim\">LTRIM</a> command tells Redis to take just list elements from index 0 to 2, everything else will be discarded. This allows for a very simple but useful pattern: doing a List push operation + a List trim operation together in order to add a new element and discard elements exceeding a limit:</p>\r\n<pre><code>LPUSH mylist &lt;some element&gt;\r\nLTRIM mylist 0 999\r\n</code></pre>\r\n<p>The above combination adds a new element and takes only the 1000 newest elements into the list. With <a href=\"http://redis.io/commands/lrange\">LRANGE</a> you can access the top items without any need to remember very old data.</p>\r\n<p>Note: while <a href=\"http://redis.io/commands/lrange\">LRANGE</a> is technically an <span class=\"math\">O(N) </span>command, accessing small ranges towards the head or the tail of the list is a constant time operation.</p>\r\n<h2>Blocking operations on lists</h2>\r\n<p>Lists have a special feature that make them suitable to implement queues, and in general as a building block for inter process communication systems: blocking operations.</p>\r\n<p>Imagine you want to push items into a list with one process, and use a different process in order to actually do some kind of work with those items. This is the usual producer / consumer setup, and can be implemented in the following simple way:</p>\r\n<ul>\r\n<li>To push items into the list, producers call <a href=\"http://redis.io/commands/lpush\">LPUSH</a>.</li>\r\n<li>To extract / process items from the list, consumers call <a href=\"http://redis.io/commands/rpop\">RPOP</a>.</li>\r\n</ul>\r\n<p>However it is possible that sometimes the list is empty and there is nothing to process, so <a href=\"http://redis.io/commands/rpop\">RPOP</a> just returns NULL. In this case a consumer is forced to wait some time and retry again with <a href=\"http://redis.io/commands/rpop\">RPOP</a>. This is called <em>polling</em>, and is not a good idea in this context because it has several drawbacks:</p>\r\n<ol>\r\n<li>Forces Redis and clients to process useless commands (all the requests when the list is empty will get no actual work done, they\'ll just return NULL).</li>\r\n<li>Adds a delay to the processing of items, since after a worker receives a NULL, it waits some time. To make the delay smaller, we could wait less between calls to <a href=\"http://redis.io/commands/rpop\">RPOP</a>, with the effect of amplifying problem number 1, i.e. more useless calls to Redis.</li>\r\n</ol>\r\n<p>So Redis implements commands called <a href=\"http://redis.io/commands/brpop\">BRPOP</a> and <a href=\"http://redis.io/commands/blpop\">BLPOP</a> which are versions of <a href=\"http://redis.io/commands/rpop\">RPOP</a> and <a href=\"http://redis.io/commands/lpop\">LPOP</a> able to block if the list is empty: they\'ll return to the caller only when a new element is added to the list, or when a user-specified timeout is reached.</p>\r\n<p>This is an example of a <a href=\"http://redis.io/commands/brpop\">BRPOP</a> call we could use in the worker:</p>\r\n<pre><code>&gt; brpop tasks 5\r\n1) \"tasks\"\r\n2) \"do_something\"\r\n</code></pre>\r\n<p>It means: \"wait for elements in the list <code>tasks</code>, but return if after 5 seconds no element is available\".</p>\r\n<p>Note that you can use 0 as timeout to wait for elements forever, and you can also specify multiple lists and not just one, in order to wait on multiple lists at the same time, and get notified when the first list receives an element.</p>\r\n<p>A few things to note about <a href=\"http://redis.io/commands/brpop\">BRPOP</a>:</p>\r\n<ol>\r\n<li>Clients are served in an ordered way: the first client that blocked waiting for a list, is served first when an element is pushed by some other client, and so forth.</li>\r\n<li>The return value is different compared to <a href=\"http://redis.io/commands/rpop\">RPOP</a>: it is a two-element array since it also includes the name of the key, because <a href=\"http://redis.io/commands/brpop\">BRPOP</a> and <a href=\"http://redis.io/commands/blpop\">BLPOP</a> are able to block waiting for elements from multiple lists.</li>\r\n<li>If the timeout is reached, NULL is returned.</li>\r\n</ol>\r\n<p>There are more things you should know about lists and blocking ops. We suggest that you read more on the following:</p>\r\n<ul>\r\n<li>It is possible to build safer queues or rotating queues using <a href=\"http://redis.io/commands/rpoplpush\">RPOPLPUSH</a>.</li>\r\n<li>There is also a blocking variant of the command, called <a href=\"http://redis.io/commands/brpoplpush\">BRPOPLPUSH</a>.</li>\r\n</ul>\r\n<h2>Automatic creation and removal of keys</h2>\r\n<p>So far in our examples we never had to create empty lists before pushing elements, or removing empty lists when they no longer have elements inside. It is Redis\' responsibility to delete keys when lists are left empty, or to create an empty list if the key does not exist and we are trying to add elements to it, for example, with <a href=\"http://redis.io/commands/lpush\">LPUSH</a>.</p>\r\n<p>This is not specific to lists, it applies to all the Redis data types composed of multiple elements -- Sets, Sorted Sets and Hashes.</p>\r\n<p>Basically we can summarize the behavior with three rules:</p>\r\n<ol>\r\n<li>When we add an element to an aggregate data type, if the target key does not exist, an empty aggregate data type is created before adding the element.</li>\r\n<li>When we remove elements from an aggregate data type, if the value remains empty, the key is automatically destroyed.</li>\r\n<li>Calling a read-only command such as <a href=\"http://redis.io/commands/llen\">LLEN</a> (which returns the length of the list), or a write command removing elements, with an empty key, always produces the same result as if the key is holding an empty aggregate type of the type the command expects to find.</li>\r\n</ol>\r\n<p>Examples of rule 1:</p>\r\n<pre><code>&gt; del mylist\r\n(integer) 1\r\n&gt; lpush mylist 1 2 3\r\n(integer) 3\r\n</code></pre>\r\n<p>However we can\'t perform operations against the wrong type of the key exists:</p>\r\n<pre><code>&gt; set foo bar\r\nOK\r\n&gt; lpush foo 1 2 3\r\n(error) WRONGTYPE Operation against a key holding the wrong kind of value\r\n&gt; type foo\r\nstring\r\n</code></pre>\r\n<p>Example of rule 2:</p>\r\n<pre><code>&gt; lpush mylist 1 2 3\r\n(integer) 3\r\n&gt; exists mylist\r\n(integer) 1\r\n&gt; lpop mylist\r\n\"3\"\r\n&gt; lpop mylist\r\n\"2\"\r\n&gt; lpop mylist\r\n\"1\"\r\n&gt; exists mylist\r\n(integer) 0\r\n</code></pre>\r\n<p>The key no longer exists after all the elements are popped.</p>\r\n<p>Example of rule 3:</p>\r\n<pre><code>&gt; del mylist\r\n(integer) 0\r\n&gt; llen mylist\r\n(integer) 0\r\n&gt; lpop mylist\r\n(nil)\r\n</code></pre>\r\n<p><a name=\"hashes\"></a></p>\r\n<h2>Redis Hashes</h2>\r\n<p>Redis hashes look exactly how one might expect a \"hash\" to look, with field-value pairs:</p>\r\n<pre><code>&gt; hmset user:1000 username antirez birthyear 1977 verified 1\r\nOK\r\n&gt; hget user:1000 username\r\n\"antirez\"\r\n&gt; hget user:1000 birthyear\r\n\"1977\"\r\n&gt; hgetall user:1000\r\n1) \"username\"\r\n2) \"antirez\"\r\n3) \"birthyear\"\r\n4) \"1977\"\r\n5) \"verified\"\r\n6) \"1\"\r\n</code></pre>\r\n<p>While hashes are handy to represent <em>objects</em>, actually the number of fields you can put inside a hash has no practical limits (other than available memory), so you can use hashes in many different ways inside your application.</p>\r\n<p>The command <a href=\"http://redis.io/commands/hmset\">HMSET</a> sets multiple fields of the hash, while <a href=\"http://redis.io/commands/hget\">HGET</a> retrieves a single field. <a href=\"http://redis.io/commands/hmget\">HMGET</a> is similar to <a href=\"http://redis.io/commands/hget\">HGET</a>but returns an array of values:</p>\r\n<pre><code>&gt; hmget user:1000 username birthyear no-such-field\r\n1) \"antirez\"\r\n2) \"1977\"\r\n3) (nil)\r\n</code></pre>\r\n<p>There are commands that are able to perform operations on individual fields as well, like <a href=\"http://redis.io/commands/hincrby\">HINCRBY</a>:</p>\r\n<pre><code>&gt; hincrby user:1000 birthyear 10\r\n(integer) 1987\r\n&gt; hincrby user:1000 birthyear 10\r\n(integer) 1997\r\n</code></pre>\r\n<p>You can find the <a href=\"http://redis.io/commands#hash\">full list of hash commands in the documentation</a>.</p>\r\n<p>It is worth noting that small hashes (i.e., a few elements with small values) are encoded in special way in memory that make them very memory efficient.</p>\r\n<p><a name=\"sets\"></a></p>\r\n<h2>Redis Sets</h2>\r\n<p>Redis Sets are unordered collections of strings. The <a href=\"http://redis.io/commands/sadd\">SADD</a> command adds new elements to a set. It\'s also possible to do a number of other operations against sets like testing if a given element already exists, performing the intersection, union or difference between multiple sets, and so forth.</p>\r\n<pre><code>&gt; sadd myset 1 2 3\r\n(integer) 3\r\n&gt; smembers myset\r\n1. 3\r\n2. 1\r\n3. 2\r\n</code></pre>\r\n<p>Here I\'ve added three elements to my set and told Redis to return all the elements. As you can see they are not sorted -- Redis is free to return the elements in any order at every call, since there is no contract with the user about element ordering.</p>\r\n<p>Redis has commands to test for membership. Does a given element exist?</p>\r\n<pre><code>&gt; sismember myset 3\r\n(integer) 1\r\n&gt; sismember myset 30\r\n(integer) 0\r\n</code></pre>\r\n<p>\"3\" is a member of the set, while \"30\" is not.</p>\r\n<p>Sets are good for expressing relations between objects. For instance we can easily use sets in order to implement tags.</p>\r\n<p>A simple way to model this problem is to have a set for every object we want to tag. The set contains the IDs of the tags associated with the object.</p>\r\n<p>Imagine we want to tag news. If our news ID 1000 is tagged with tags 1, 2, 5 and 77, we can have one set associating our tag IDs with the news item:</p>\r\n<pre><code>&gt; sadd news:1000:tags 1 2 5 77\r\n(integer) 4\r\n</code></pre>\r\n<p>However sometimes I may want to have the inverse relation as well: the list of all the news tagged with a given tag:</p>\r\n<pre><code>&gt; sadd tag:1:news 1000\r\n(integer) 1\r\n&gt; sadd tag:2:news 1000\r\n(integer) 1\r\n&gt; sadd tag:5:news 1000\r\n(integer) 1\r\n&gt; sadd tag:77:news 1000\r\n(integer) 1\r\n</code></pre>\r\n<p>To get all the tags for a given object is trivial:</p>\r\n<pre><code>&gt; smembers news:1000:tags\r\n1. 5\r\n2. 1\r\n3. 77\r\n4. 2\r\n</code></pre>\r\n<p>Note: in the example we assume you have another data structure, for example a Redis hash, which maps tag IDs to tag names.</p>\r\n<p>There are other non trivial operations that are still easy to implement using the right Redis commands. For instance we may want a list of all the objects with the tags 1, 2, 10, and 27 together. We can do this using the <a href=\"http://redis.io/commands/sinter\">SINTER</a>command, which performs the intersection between different sets. We can use:</p>\r\n<pre><code>&gt; sinter tag:1:news tag:2:news tag:10:news tag:27:news\r\n... results here ...\r\n</code></pre>\r\n<p>Intersection is not the only operation performed, you can also perform unions, difference, extract a random element, and so forth.</p>\r\n<p>The command to extract an element is called <a href=\"http://redis.io/commands/spop\">SPOP</a>, and is handy to model certain problems. For example in order to implement a web-based poker game, you may want to represent your deck with a set. Imagine we use a one-char prefix for (C)lubs, (D)iamonds, (H)earts, (S)pades:</p>\r\n<pre><code>&gt;  sadd deck C1 C2 C3 C4 C5 C6 C7 C8 C9 C10 CJ CQ CK\r\n   D1 D2 D3 D4 D5 D6 D7 D8 D9 D10 DJ DQ DK H1 H2 H3\r\n   H4 H5 H6 H7 H8 H9 H10 HJ HQ HK S1 S2 S3 S4 S5 S6\r\n   S7 S8 S9 S10 SJ SQ SK\r\n   (integer) 52\r\n</code></pre>\r\n<p>Now we want to provide each player with 5 cards. The <a href=\"http://redis.io/commands/spop\">SPOP</a> command removes a random element, returning it to the client, so it is the perfect operation in this case.</p>\r\n<p>However if we call it against our deck directly, in the next play of the game we\'ll need to populate the deck of cards again, which may not be ideal. So to start, we can make a copy of the set stored in the <code>deck</code> key into the <code>game:1:deck</code>key.</p>\r\n<p>This is accomplished using <a href=\"http://redis.io/commands/sunionstore\">SUNIONSTORE</a>, which normally performs the union between multiple sets, and stores the result into another set. However, since the union of a single set is itself, I can copy my deck with:</p>\r\n<pre><code>&gt; sunionstore game:1:deck deck\r\n(integer) 52\r\n</code></pre>\r\n<p>Now I\'m ready to provide the first player with five cards:</p>\r\n<pre><code>&gt; spop game:1:deck\r\n\"C6\"\r\n&gt; spop game:1:deck\r\n\"CQ\"\r\n&gt; spop game:1:deck\r\n\"D1\"\r\n&gt; spop game:1:deck\r\n\"CJ\"\r\n&gt; spop game:1:deck\r\n\"SJ\"\r\n</code></pre>\r\n<p>One pair of jacks, not great...</p>\r\n<p>Now it\'s a good time to introduce the set command that provides the number of elements inside a set. This is often called the <em>cardinality of a set</em> in the context of set theory, so the Redis command is called <a href=\"http://redis.io/commands/scard\">SCARD</a>.</p>\r\n<pre><code>&gt; scard game:1:deck\r\n(integer) 47\r\n</code></pre>\r\n<p>The math works: 52 - 5 = 47.</p>\r\n<p>When you need to just get random elements without removing them from the set, there is the <a href=\"http://redis.io/commands/srandmember\">SRANDMEMBER</a>command suitable for the task. It also features the ability to return both repeating and non-repeating elements.</p>\r\n<p><a name=\"sorted-sets\"></a></p>\r\n<h2>Redis Sorted sets</h2>\r\n<p>Sorted sets are a data type which is similar to a mix between a Set and a Hash. Like sets, sorted sets are composed of unique, non-repeating string elements, so in some sense a sorted set is a set as well.</p>\r\n<p>However while elements inside sets are not ordered, every element in a sorted set is associated with a floating point value, called <em>the score</em> (this is why the type is also similar to a hash, since every element is mapped to a value).</p>\r\n<p>Moreover, elements in a sorted sets are <em>taken in order</em> (so they are not ordered on request, order is a peculiarity of the data structure used to represent sorted sets). They are ordered according to the following rule:</p>\r\n<ul>\r\n<li>If A and B are two elements with a different score, then A &gt; B if A.score is &gt; B.score.</li>\r\n<li>If A and B have exactly the same score, then A &gt; B if the A string is lexicographically greater than the B string. A and B strings can\'t be equal since sorted sets only have unique elements.</li>\r\n</ul>\r\n<p>Let\'s start with a simple example, adding a few selected hackers names as sorted set elements, with their year of birth as \"score\".</p>\r\n<pre><code>&gt; zadd hackers 1940 \"Alan Kay\"\r\n(integer) 1\r\n&gt; zadd hackers 1957 \"Sophie Wilson\"\r\n(integer 1)\r\n&gt; zadd hackers 1953 \"Richard Stallman\"\r\n(integer) 1\r\n&gt; zadd hackers 1949 \"Anita Borg\"\r\n(integer) 1\r\n&gt; zadd hackers 1965 \"Yukihiro Matsumoto\"\r\n(integer) 1\r\n&gt; zadd hackers 1914 \"Hedy Lamarr\"\r\n(integer) 1\r\n&gt; zadd hackers 1916 \"Claude Shannon\"\r\n(integer) 1\r\n&gt; zadd hackers 1969 \"Linus Torvalds\"\r\n(integer) 1\r\n&gt; zadd hackers 1912 \"Alan Turing\"\r\n(integer) 1\r\n</code></pre>\r\n<p>As you can see <a href=\"http://redis.io/commands/zadd\">ZADD</a> is similar to <a href=\"http://redis.io/commands/sadd\">SADD</a>, but takes one additional argument (placed before the element to be added) which is the score. <a href=\"http://redis.io/commands/zadd\">ZADD</a> is also variadic, so you are free to specify multiple score-value pairs, even if this is not used in the example above.</p>\r\n<p>With sorted sets it is trivial to return a list of hackers sorted by their birth year because actually <em>they are already sorted</em>.</p>\r\n<p>Implementation note: Sorted sets are implemented via a dual-ported data structure containing both a skip list and a hash table, so every time we add an element Redis performs an <span class=\"math\">O(log(N)) </span>operation. That\'s good, but when we ask for sorted elements Redis does not have to do any work at all, it\'s already all sorted:</p>\r\n<pre><code>&gt; zrange hackers 0 -1\r\n1) \"Alan Turing\"\r\n2) \"Hedy Lamarr\"\r\n3) \"Claude Shannon\"\r\n4) \"Alan Kay\"\r\n5) \"Anita Borg\"\r\n6) \"Richard Stallman\"\r\n7) \"Sophie Wilson\"\r\n8) \"Yukihiro Matsumoto\"\r\n9) \"Linus Torvalds\"\r\n</code></pre>\r\n<p>Note: 0 and -1 means from element index 0 to the last element (-1 works here just as it does in the case of the<a href=\"http://redis.io/commands/lrange\">LRANGE</a> command).</p>\r\n<p>What if I want to order them the opposite way, youngest to oldest? Use <a href=\"http://redis.io/commands/zrevrange\">ZREVRANGE</a> instead of <a href=\"http://redis.io/commands/zrange\">ZRANGE</a>:</p>\r\n<pre><code>&gt; zrevrange hackers 0 -1\r\n1) \"Linus Torvalds\"\r\n2) \"Yukihiro Matsumoto\"\r\n3) \"Sophie Wilson\"\r\n4) \"Richard Stallman\"\r\n5) \"Anita Borg\"\r\n6) \"Alan Kay\"\r\n7) \"Claude Shannon\"\r\n8) \"Hedy Lamarr\"\r\n9) \"Alan Turing\"\r\n</code></pre>\r\n<p>It is possible to return scores as well, using the <code>WITHSCORES</code> argument:</p>\r\n<pre><code>&gt; zrange hackers 0 -1 withscores\r\n1) \"Alan Turing\"\r\n2) \"1912\"\r\n3) \"Hedy Lamarr\"\r\n4) \"1914\"\r\n5) \"Claude Shannon\"\r\n6) \"1916\"\r\n7) \"Alan Kay\"\r\n8) \"1940\"\r\n9) \"Anita Borg\"\r\n10) \"1949\"\r\n11) \"Richard Stallman\"\r\n12) \"1953\"\r\n13) \"Sophie Wilson\"\r\n14) \"1957\"\r\n15) \"Yukihiro Matsumoto\"\r\n16) \"1965\"\r\n17) \"Linus Torvalds\"\r\n18) \"1969\"\r\n</code></pre>\r\n<h2>Operating on ranges</h2>\r\n<p>Sorted sets are more powerful than this. They can operate on ranges. Let\'s get all the individuals that were born up to 1950 inclusive. We use the <a href=\"http://redis.io/commands/zrangebyscore\">ZRANGEBYSCORE</a> command to do it:</p>\r\n<pre><code>&gt; zrangebyscore hackers -inf 1950\r\n1) \"Alan Turing\"\r\n2) \"Hedy Lamarr\"\r\n3) \"Claude Shannon\"\r\n4) \"Alan Kay\"\r\n5) \"Anita Borg\"\r\n</code></pre>\r\n<p>We asked Redis to return all the elements with a score between negative infinity and 1950 (both extremes are included).</p>\r\n<p>It\'s also possible to remove ranges of elements. Let\'s remove all the hackers born between 1940 and 1960 from the sorted set:</p>\r\n<pre><code>&gt; zremrangebyscore hackers 1940 1960\r\n(integer) 4\r\n</code></pre>\r\n<p><a href=\"http://redis.io/commands/zremrangebyscore\">ZREMRANGEBYSCORE</a> is perhaps not the best command name, but it can be very useful, and returns the number of removed elements.</p>\r\n<p>Another extremely useful operation defined for sorted set elements is the get-rank operation. It is possible to ask what is the position of an element in the set of the ordered elements.</p>\r\n<pre><code>&gt; zrank hackers \"Anita Borg\"\r\n(integer) 4\r\n</code></pre>\r\n<p>The <a href=\"http://redis.io/commands/zrevrank\">ZREVRANK</a> command is also available in order to get the rank, considering the elements sorted a descending way.</p>\r\n<h2>Lexicographical scores</h2>\r\n<p>With recent versions of Redis 2.8, a new feature was introduced that allows getting ranges lexicographically, assuming elements in a sorted set are all inserted with the same identical score (elements are compared with the C <code>memcmp</code>function, so it is guaranteed that there is no collation, and every Redis instance will reply with the same output).</p>\r\n<p>The main commands to operate with lexicographical ranges are <a href=\"http://redis.io/commands/zrangebylex\">ZRANGEBYLEX</a>, <a href=\"http://redis.io/commands/zrevrangebylex\">ZREVRANGEBYLEX</a>,<a href=\"http://redis.io/commands/zremrangebylex\">ZREMRANGEBYLEX</a> and <a href=\"http://redis.io/commands/zlexcount\">ZLEXCOUNT</a>.</p>\r\n<p>For example, let\'s add again our list of famous hackers, but this time use a score of zero for all the elements:</p>\r\n<pre><code>&gt; zadd hackers 0 \"Alan Kay\" 0 \"Sophie Wilson\" 0 \"Richard Stallman\" 0\r\n  \"Anita Borg\" 0 \"Yukihiro Matsumoto\" 0 \"Hedy Lamarr\" 0 \"Claude Shannon\"\r\n  0 \"Linus Torvalds\" 0 \"Alan Turing\"\r\n</code></pre>\r\n<p>Because of the sorted sets ordering rules, they are already sorted lexicographically:</p>\r\n<pre><code>&gt; zrange hackers 0 -1\r\n1) \"Alan Kay\"\r\n2) \"Alan Turing\"\r\n3) \"Anita Borg\"\r\n4) \"Claude Shannon\"\r\n5) \"Hedy Lamarr\"\r\n6) \"Linus Torvalds\"\r\n7) \"Richard Stallman\"\r\n8) \"Sophie Wilson\"\r\n9) \"Yukihiro Matsumoto\"\r\n</code></pre>\r\n<p>Using <a href=\"http://redis.io/commands/zrangebylex\">ZRANGEBYLEX</a> we can ask for lexicographical ranges:</p>\r\n<pre><code>&gt; zrangebylex hackers [B [P\r\n1) \"Claude Shannon\"\r\n2) \"Hedy Lamarr\"\r\n3) \"Linus Torvalds\"\r\n</code></pre>\r\n<p>Ranges can be inclusive or exclusive (depending on the first character), also string infinite and minus infinite are specified respectively with the <code>+</code> and <code>-</code> strings. See the documentation for more information.</p>\r\n<p>This feature is important because it allows us to use sorted sets as a generic index. For example, if you want to index elements by a 128-bit unsigned integer argument, all you need to do is to add elements into a sorted set with the same score (for example 0) but with an 8 byte prefix consisting of <strong>the 128 bit number in big endian</strong>. Since numbers in big endian, when ordered lexicographically (in raw bytes order) are actually ordered numerically as well, you can ask for ranges in the 128 bit space, and get the element\'s value discarding the prefix.</p>\r\n<p>If you want to see the feature in the context of a more serious demo, check the <a href=\"http://autocomplete.redis.io/\">Redis autocomplete demo</a>.</p>\r\n<h2>Updating the score: leader boards</h2>\r\n<p>Just a final note about sorted sets before switching to the next topic. Sorted sets\' scores can be updated at any time. Just calling <a href=\"http://redis.io/commands/zadd\">ZADD</a> against an element already included in the sorted set will update its score (and position) with<span class=\"math\">O(log(N)) </span>time complexity. As such, sorted sets are suitable when there are tons of updates.</p>\r\n<p>Because of this characteristic a common use case is leader boards. The typical application is a Facebook game where you combine the ability to take users sorted by their high score, plus the get-rank operation, in order to show the top-N users, and the user rank in the leader board (e.g., \"you are the #4932 best score here\").</p>\r\n<p><a name=\"bitmaps\"></a></p>\r\n<h2>Bitmaps</h2>\r\n<p>Bitmaps are not an actual data type, but a set of bit-oriented operations defined on the String type. Since strings are binary safe blobs and their maximum length is 512 MB, they are suitable to set up to 2<sup>32</sup> different bits.</p>\r\n<p>Bit operations are divided into two groups: constant-time single bit operations, like setting a bit to 1 or 0, or getting its value, and operations on groups of bits, for example counting the number of set bits in a given range of bits (e.g., population counting).</p>\r\n<p>One of the biggest advantages of bitmaps is that they often provide extreme space savings when storing information. For example in a system where different users are represented by incremental user IDs, it is possible to remember a single bit information (for example, knowing whether a user wants to receive a newsletter) of 4 billion of users using just 512 MB of memory.</p>\r\n<p>Bits are set and retrieved using the <a href=\"http://redis.io/commands/setbit\">SETBIT</a> and <a href=\"http://redis.io/commands/getbit\">GETBIT</a> commands:</p>\r\n<pre><code>&gt; setbit key 10 1\r\n(integer) 1\r\n&gt; getbit key 10\r\n(integer) 1\r\n&gt; getbit key 11\r\n(integer) 0\r\n</code></pre>\r\n<p>The <a href=\"http://redis.io/commands/setbit\">SETBIT</a> command takes as its first argument the bit number, and as its second argument the value to set the bit to, which is 1 or 0. The command automatically enlarges the string if the addressed bit is outside the current string length.</p>\r\n<p><a href=\"http://redis.io/commands/getbit\">GETBIT</a> just returns the value of the bit at the specified index. Out of range bits (addressing a bit that is outside the length of the string stored into the target key) are always considered to be zero.</p>\r\n<p>There are three commands operating on group of bits:</p>\r\n<ol>\r\n<li><a href=\"http://redis.io/commands/bitop\">BITOP</a> performs bit-wise operations between different strings. The provided operations are AND, OR, XOR and NOT.</li>\r\n<li><a href=\"http://redis.io/commands/bitcount\">BITCOUNT</a> performs population counting, reporting the number of bits set to 1.</li>\r\n<li><a href=\"http://redis.io/commands/bitpos\">BITPOS</a> finds the first bit having the specified value of 0 or 1.</li>\r\n</ol>\r\n<p>Both <a href=\"http://redis.io/commands/bitpos\">BITPOS</a> and <a href=\"http://redis.io/commands/bitcount\">BITCOUNT</a> are able to operate with byte ranges of the string, instead of running for the whole length of the string. The following is a trivial example of <a href=\"http://redis.io/commands/bitcount\">BITCOUNT</a> call:</p>\r\n<pre><code>&gt; setbit key 0 1\r\n(integer) 0\r\n&gt; setbit key 100 1\r\n(integer) 0\r\n&gt; bitcount key\r\n(integer) 2\r\n</code></pre>\r\n<p>Common user cases for bitmaps are:</p>\r\n<ul>\r\n<li>Real time analytics of all kinds.</li>\r\n<li>Storing space efficient but high performance boolean information associated with object IDs.</li>\r\n</ul>\r\n<p>For example imagine you want to know the longest streak of daily visits of your web site users. You start counting days starting from zero, that is the day you made your web site public, and set a bit with <a href=\"http://redis.io/commands/setbit\">SETBIT</a> every time the user visits the web site. As a bit index you simply take the current unix time, subtract the initial offset, and divide by 3600*24.</p>\r\n<p>This way for each user you have a small string containing the visit information for each day. With <a href=\"http://redis.io/commands/bitcount\">BITCOUNT</a> it is possible to easily get the number of days a given user visited the web site, while with a few <a href=\"http://redis.io/commands/bitpos\">BITPOS</a> calls, or simply fetching and analyzing the bitmap client-side, it is possible to easily compute the longest streak.</p>\r\n<p>Bitmaps are trivial to split into multiple keys, for example for the sake of sharding the data set and because in general it is better to avoid working with huge keys. To split a bitmap across different keys instead of setting all the bits into a key, a trivial strategy is just to store M bits per key and obtain the key name with <code>bit-number/M</code> and the Nth bit to address inside the key with <code>bit-number MOD M</code>.</p>\r\n<p><a name=\"hyperloglogs\"></a></p>\r\n<h2>HyperLogLogs</h2>\r\n<p>A HyperLogLog is a probabilistic data structure used in order to count unique things (technically this is referred to estimating the cardinality of a set). Usually counting unique items requires using an amount of memory proportional to the number of items you want to count, because you need to remember the elements you have already seen in the past in order to avoid counting them multiple times. However there is a set of algorithms that trade memory for precision: you end with an estimated measure with a standard error, in the case of the Redis implementation, which is less than 1%. The magic of this algorithm is that you no longer need to use an amount of memory proportional to the number of items counted, and instead can use a constant amount of memory! 12k bytes in the worst case, or a lot less if your HyperLogLog (We\'ll just call them HLL from now) has seen very few elements.</p>\r\n<p>HLLs in Redis, while technically a different data structure, is encoded as a Redis string, so you can call <a href=\"http://redis.io/commands/get\">GET</a> to serialize a HLL, and <a href=\"http://redis.io/commands/set\">SET</a> to deserialize it back to the server.</p>\r\n<p>Conceptually the HLL API is like using Sets to do the same task. You would <a href=\"http://redis.io/commands/sadd\">SADD</a> every observed element into a set, and would use <a href=\"http://redis.io/commands/scard\">SCARD</a> to check the number of elements inside the set, which are unique since <a href=\"http://redis.io/commands/sadd\">SADD</a> will not re-add an existing element.</p>\r\n<p>While you don\'t really <em>add items</em> into an HLL, because the data structure only contains a state that does not include actual elements, the API is the same:</p>\r\n<ul>\r\n<li>Every time you see a new element, you add it to the count with <a href=\"http://redis.io/commands/pfadd\">PFADD</a>.</li>\r\n<li>\r\n<p>Every time you want to retrieve the current approximation of the unique elements <em>added</em> with <a href=\"http://redis.io/commands/pfadd\">PFADD</a> so far, you use the <a href=\"http://redis.io/commands/pfcount\">PFCOUNT</a>.</p>\r\n<pre><code>&gt; pfadd hll a b c d\r\n(integer) 1\r\n&gt; pfcount hll\r\n(integer) 4\r\n</code></pre>\r\n</li>\r\n</ul>\r\n<p>An example of use case for this data structure is counting unique queries performed by users in a search form every day.</p>\r\n<p>Redis is also able to perform the union of HLLs, please check the <a href=\"http://redis.io/commands#hyperloglog\">full documentation</a> for more information.</p>\r\n<h2>Other notable features</h2>\r\n<p>There are other important things in the Redis API that can\'t be explored in the context of this document, but are worth your attention:</p>\r\n<ul>\r\n<li>It is possible to <a href=\"http://redis.io/commands/scan\">iterate the key space of a large collection incrementally</a>.</li>\r\n<li>It is possible to run <a href=\"http://redis.io/commands/eval\">Lua scripts server side</a> to win latency and bandwidth.</li>\r\n<li>Redis is also a <a href=\"http://redis.io/topics/pubsub\">Pub-Sub server</a>.</li>\r\n</ul>\r\n<h2>Learn more</h2>\r\n<p>This tutorial is in no way complete and has covered just the basics of the API. Read the <a href=\"http://redis.io/commands\">command reference</a> to discover a lot more.</p>\r\n<p>Thanks for reading, and have fun hacking with Redis!</p>','redis官网','2015-11-02 20:11:00',7),(18,'redis-py','<p>The Python interface to the Redis key-value store.</p>\r\n<p><a href=\"http://travis-ci.org/andymccurdy/redis-py\"><img src=\"https://camo.githubusercontent.com/7c5c7d1d83d31ba63a1355f11e254eee58ac85e7/68747470733a2f2f7365637572652e7472617669732d63692e6f72672f616e64796d6363757264792f72656469732d70792e706e673f6272616e63683d6d6173746572\" alt=\"https://secure.travis-ci.org/andymccurdy/redis-py.png?branch=master\" data-canonical-src=\"https://secure.travis-ci.org/andymccurdy/redis-py.png?branch=master\" /></a><a name=\"user-content-installation\"></a></p>\r\n<h2><a id=\"user-content-installation\" class=\"anchor\" href=\"https://github.com/andymccurdy/redis-py#installation\"></a>Installation</h2>\r\n<p>redis-py requires a running Redis server. See <a href=\"http://redis.io/topics/quickstart\">Redis\'s quickstart</a> for installation instructions.</p>\r\n<p>To install redis-py, simply:</p>\r\n<div class=\"highlight highlight-source-shell\">\r\n<pre>$ sudo pip install redis</pre>\r\n</div>\r\n<p>or alternatively (you really should be using pip though):</p>\r\n<div class=\"highlight highlight-source-shell\">\r\n<pre>$ sudo easy_install redis</pre>\r\n</div>\r\n<p>or from source:</p>\r\n<div class=\"highlight highlight-source-shell\">\r\n<pre>$ sudo python setup.py install</pre>\r\n</div>\r\n<p><a name=\"user-content-getting-started\"></a></p>\r\n<h2><a id=\"user-content-getting-started\" class=\"anchor\" href=\"https://github.com/andymccurdy/redis-py#getting-started\"></a>Getting Started</h2>\r\n<pre lang=\"pycon\">&gt;&gt;&gt; import redis\r\n&gt;&gt;&gt; r = redis.StrictRedis(host=\'localhost\', port=6379, db=0)\r\n&gt;&gt;&gt; r.set(\'foo\', \'bar\')\r\nTrue\r\n&gt;&gt;&gt; r.get(\'foo\')\r\n\'bar\'\r\n</pre>\r\n<p><a name=\"user-content-api-reference\"></a></p>\r\n<h2><a id=\"user-content-api-reference\" class=\"anchor\" href=\"https://github.com/andymccurdy/redis-py#api-reference\"></a>API Reference</h2>\r\n<p>The <a href=\"http://redis.io/commands\">official Redis command documentation</a> does a great job of explaining each command in detail. redis-py exposes two client classes that implement these commands. The StrictRedis class attempts to adhere to the official command syntax. There are a few exceptions:</p>\r\n<ul>\r\n<li><strong>SELECT</strong>: Not implemented. See the explanation in the Thread Safety section below.</li>\r\n<li><strong>DEL</strong>: \'del\' is a reserved keyword in the Python syntax. Therefore redis-py uses \'delete\' instead.</li>\r\n<li><strong>CONFIG GET|SET</strong>: These are implemented separately as config_get or config_set.</li>\r\n<li><strong>MULTI/EXEC</strong>: These are implemented as part of the Pipeline class. The pipeline is wrapped with the MULTI and EXEC statements by default when it is executed, which can be disabled by specifying transaction=False. See more about Pipelines below.</li>\r\n<li><strong>SUBSCRIBE/LISTEN</strong>: Similar to pipelines, PubSub is implemented as a separate class as it places the underlying connection in a state where it can\'t execute non-pubsub commands. Calling the pubsub method from the Redis client will return a PubSub instance where you can subscribe to channels and listen for messages. You can only call PUBLISH from the Redis client (see <a href=\"https://github.com/andymccurdy/redis-py/issues/151#issuecomment-1545015\">this comment on issue #151</a> for details).</li>\r\n<li><strong>SCAN/SSCAN/HSCAN/ZSCAN</strong>: The *SCAN commands are implemented as they exist in the Redis documentation. In addition, each command has an equivilant iterator method. These are purely for convenience so the user doesn\'t have to keep track of the cursor while iterating. Use the scan_iter/sscan_iter/hscan_iter/zscan_iter methods for this behavior.</li>\r\n</ul>\r\n<p>In addition to the changes above, the Redis class, a subclass of StrictRedis, overrides several other commands to provide backwards compatibility with older versions of redis-py:</p>\r\n<ul>\r\n<li><strong>LREM</strong>: Order of \'num\' and \'value\' arguments reversed such that \'num\' can provide a default value of zero.</li>\r\n<li><strong>ZADD</strong>: Redis specifies the \'score\' argument before \'value\'. These were swapped accidentally when being implemented and not discovered until after people were already using it. The Redis class expects *args in the form of: name1, score1, name2, score2, ...</li>\r\n<li><strong>SETEX</strong>: Order of \'time\' and \'value\' arguments reversed.</li>\r\n</ul>\r\n<p><a name=\"user-content-more-detail\"></a></p>\r\n<h2><a id=\"user-content-more-detail\" class=\"anchor\" href=\"https://github.com/andymccurdy/redis-py#more-detail\"></a>More Detail</h2>\r\n<p><a name=\"user-content-connection-pools\"></a></p>\r\n<h3><a id=\"user-content-connection-pools\" class=\"anchor\" href=\"https://github.com/andymccurdy/redis-py#connection-pools\"></a>Connection Pools</h3>\r\n<p>Behind the scenes, redis-py uses a connection pool to manage connections to a Redis server. By default, each Redis instance you create will in turn create its own connection pool. You can override this behavior and use an existing connection pool by passing an already created connection pool instance to the connection_pool argument of the Redis class. You may choose to do this in order to implement client side sharding or have finer grain control of how connections are managed.</p>\r\n<pre lang=\"pycon\">&gt;&gt;&gt; pool = redis.ConnectionPool(host=\'localhost\', port=6379, db=0)\r\n&gt;&gt;&gt; r = redis.Redis(connection_pool=pool)\r\n</pre>\r\n<p><a name=\"user-content-connections\"></a></p>\r\n<h3><a id=\"user-content-connections\" class=\"anchor\" href=\"https://github.com/andymccurdy/redis-py#connections\"></a>Connections</h3>\r\n<p>ConnectionPools manage a set of Connection instances. redis-py ships with two types of Connections. The default, Connection, is a normal TCP socket based connection. The UnixDomainSocketConnection allows for clients running on the same device as the server to connect via a unix domain socket. To use a UnixDomainSocketConnection connection, simply pass the unix_socket_path argument, which is a string to the unix domain socket file. Additionally, make sure the unixsocket parameter is defined in your redis.conf file. It\'s commented out by default.</p>\r\n<pre lang=\"pycon\">&gt;&gt;&gt; r = redis.Redis(unix_socket_path=\'/tmp/redis.sock\')\r\n</pre>\r\n<p>You can create your own Connection subclasses as well. This may be useful if you want to control the socket behavior within an async framework. To instantiate a client class using your own connection, you need to create a connection pool, passing your class to the connection_class argument. Other keyword parameters you pass to the pool will be passed to the class specified during initialization.</p>\r\n<pre lang=\"pycon\">&gt;&gt;&gt; pool = redis.ConnectionPool(connection_class=YourConnectionClass,\r\n                                your_arg=\'...\', ...)\r\n</pre>\r\n<p><a name=\"user-content-parsers\"></a></p>\r\n<h3><a id=\"user-content-parsers\" class=\"anchor\" href=\"https://github.com/andymccurdy/redis-py#parsers\"></a>Parsers</h3>\r\n<p>Parser classes provide a way to control how responses from the Redis server are parsed. redis-py ships with two parser classes, the PythonParser and the HiredisParser. By default, redis-py will attempt to use the HiredisParser if you have the hiredis module installed and will fallback to the PythonParser otherwise.</p>\r\n<p>Hiredis is a C library maintained by the core Redis team. Pieter Noordhuis was kind enough to create Python bindings. Using Hiredis can provide up to a 10x speed improvement in parsing responses from the Redis server. The performance increase is most noticeable when retrieving many pieces of data, such as from LRANGE or SMEMBERS operations.</p>\r\n<p>Hiredis is available on PyPI, and can be installed via pip or easy_install just like redis-py.</p>\r\n<div class=\"highlight highlight-source-shell\">\r\n<pre>$ pip install hiredis</pre>\r\n</div>\r\n<p>or</p>\r\n<div class=\"highlight highlight-source-shell\">\r\n<pre>$ easy_install hiredis</pre>\r\n</div>\r\n<p><a name=\"user-content-response-callbacks\"></a></p>\r\n<h3><a id=\"user-content-response-callbacks\" class=\"anchor\" href=\"https://github.com/andymccurdy/redis-py#response-callbacks\"></a>Response Callbacks</h3>\r\n<p>The client class uses a set of callbacks to cast Redis responses to the appropriate Python type. There are a number of these callbacks defined on the Redis client class in a dictionary called RESPONSE_CALLBACKS.</p>\r\n<p>Custom callbacks can be added on a per-instance basis using the set_response_callback method. This method accepts two arguments: a command name and the callback. Callbacks added in this manner are only valid on the instance the callback is added to. If you want to define or override a callback globally, you should make a subclass of the Redis client and add your callback to its REDIS_CALLBACKS class dictionary.</p>\r\n<p>Response callbacks take at least one parameter: the response from the Redis server. Keyword arguments may also be accepted in order to further control how to interpret the response. These keyword arguments are specified during the command\'s call to execute_command. The ZRANGE implementation demonstrates the use of response callback keyword arguments with its \"withscores\" argument.</p>\r\n<p><a name=\"user-content-thread-safety\"></a></p>\r\n<h3><a id=\"user-content-thread-safety\" class=\"anchor\" href=\"https://github.com/andymccurdy/redis-py#thread-safety\"></a>Thread Safety</h3>\r\n<p>Redis client instances can safely be shared between threads. Internally, connection instances are only retrieved from the connection pool during command execution, and returned to the pool directly after. Command execution never modifies state on the client instance.</p>\r\n<p>However, there is one caveat: the Redis SELECT command. The SELECT command allows you to switch the database currently in use by the connection. That database remains selected until another is selected or until the connection is closed. This creates an issue in that connections could be returned to the pool that are connected to a different database.</p>\r\n<p>As a result, redis-py does not implement the SELECT command on client instances. If you use multiple Redis databases within the same application, you should create a separate client instance (and possibly a separate connection pool) for each database.</p>\r\n<p>It is not safe to pass PubSub or Pipeline objects between threads.</p>\r\n<p><a name=\"user-content-pipelines\"></a></p>\r\n<h3><a id=\"user-content-pipelines\" class=\"anchor\" href=\"https://github.com/andymccurdy/redis-py#pipelines\"></a>Pipelines</h3>\r\n<p>Pipelines are a subclass of the base Redis class that provide support for buffering multiple commands to the server in a single request. They can be used to dramatically increase the performance of groups of commands by reducing the number of back-and-forth TCP packets between the client and server.</p>\r\n<p>Pipelines are quite simple to use:</p>\r\n<pre lang=\"pycon\">&gt;&gt;&gt; r = redis.Redis(...)\r\n&gt;&gt;&gt; r.set(\'bing\', \'baz\')\r\n&gt;&gt;&gt; # Use the pipeline() method to create a pipeline instance\r\n&gt;&gt;&gt; pipe = r.pipeline()\r\n&gt;&gt;&gt; # The following SET commands are buffered\r\n&gt;&gt;&gt; pipe.set(\'foo\', \'bar\')\r\n&gt;&gt;&gt; pipe.get(\'bing\')\r\n&gt;&gt;&gt; # the EXECUTE call sends all buffered commands to the server, returning\r\n&gt;&gt;&gt; # a list of responses, one for each command.\r\n&gt;&gt;&gt; pipe.execute()\r\n[True, \'baz\']\r\n</pre>\r\n<p>For ease of use, all commands being buffered into the pipeline return the pipeline object itself. Therefore calls can be chained like:</p>\r\n<pre lang=\"pycon\">&gt;&gt;&gt; pipe.set(\'foo\', \'bar\').sadd(\'faz\', \'baz\').incr(\'auto_number\').execute()\r\n[True, True, 6]\r\n</pre>\r\n<p>In addition, pipelines can also ensure the buffered commands are executed atomically as a group. This happens by default. If you want to disable the atomic nature of a pipeline but still want to buffer commands, you can turn off transactions.</p>\r\n<pre lang=\"pycon\">&gt;&gt;&gt; pipe = r.pipeline(transaction=False)\r\n</pre>\r\n<p>A common issue occurs when requiring atomic transactions but needing to retrieve values in Redis prior for use within the transaction. For instance, let\'s assume that the INCR command didn\'t exist and we need to build an atomic version of INCR in Python.</p>\r\n<p>The completely naive implementation could GET the value, increment it in Python, and SET the new value back. However, this is not atomic because multiple clients could be doing this at the same time, each getting the same value from GET.</p>\r\n<p>Enter the WATCH command. WATCH provides the ability to monitor one or more keys prior to starting a transaction. If any of those keys change prior the execution of that transaction, the entire transaction will be canceled and a WatchError will be raised. To implement our own client-side INCR command, we could do something like this:</p>\r\n<pre lang=\"pycon\">&gt;&gt;&gt; with r.pipeline() as pipe:\r\n...     while 1:\r\n...         try:\r\n...             # put a WATCH on the key that holds our sequence value\r\n...             pipe.watch(\'OUR-SEQUENCE-KEY\')\r\n...             # after WATCHing, the pipeline is put into immediate execution\r\n...             # mode until we tell it to start buffering commands again.\r\n...             # this allows us to get the current value of our sequence\r\n...             current_value = pipe.get(\'OUR-SEQUENCE-KEY\')\r\n...             next_value = int(current_value) + 1\r\n...             # now we can put the pipeline back into buffered mode with MULTI\r\n...             pipe.multi()\r\n...             pipe.set(\'OUR-SEQUENCE-KEY\', next_value)\r\n...             # and finally, execute the pipeline (the set command)\r\n...             pipe.execute()\r\n...             # if a WatchError wasn\'t raised during execution, everything\r\n...             # we just did happened atomically.\r\n...             break\r\n...        except WatchError:\r\n...             # another client must have changed \'OUR-SEQUENCE-KEY\' between\r\n...             # the time we started WATCHing it and the pipeline\'s execution.\r\n...             # our best bet is to just retry.\r\n...             continue\r\n</pre>\r\n<p>Note that, because the Pipeline must bind to a single connection for the duration of a WATCH, care must be taken to ensure that the connection is returned to the connection pool by calling the reset() method. If the Pipeline is used as a context manager (as in the example above) reset() will be called automatically. Of course you can do this the manual way by explicity calling reset():</p>\r\n<pre lang=\"pycon\">&gt;&gt;&gt; pipe = r.pipeline()\r\n&gt;&gt;&gt; while 1:\r\n...     try:\r\n...         pipe.watch(\'OUR-SEQUENCE-KEY\')\r\n...         ...\r\n...         pipe.execute()\r\n...         break\r\n...     except WatchError:\r\n...         continue\r\n...     finally:\r\n...         pipe.reset()\r\n</pre>\r\n<p>A convenience method named \"transaction\" exists for handling all the boilerplate of handling and retrying watch errors. It takes a callable that should expect a single parameter, a pipeline object, and any number of keys to be WATCHed. Our client-side INCR command above can be written like this, which is much easier to read:</p>\r\n<pre lang=\"pycon\">&gt;&gt;&gt; def client_side_incr(pipe):\r\n...     current_value = pipe.get(\'OUR-SEQUENCE-KEY\')\r\n...     next_value = int(current_value) + 1\r\n...     pipe.multi()\r\n...     pipe.set(\'OUR-SEQUENCE-KEY\', next_value)\r\n&gt;&gt;&gt;\r\n&gt;&gt;&gt; r.transaction(client_side_incr, \'OUR-SEQUENCE-KEY\')\r\n[True]\r\n</pre>\r\n<p><a name=\"user-content-publish-subscribe\"></a></p>\r\n<h3><a id=\"user-content-publish--subscribe\" class=\"anchor\" href=\"https://github.com/andymccurdy/redis-py#publish--subscribe\"></a>Publish / Subscribe</h3>\r\n<p>redis-py includes a PubSub object that subscribes to channels and listens for new messages. Creating a PubSub object is easy.</p>\r\n<pre lang=\"pycon\">&gt;&gt;&gt; r = redis.StrictRedis(...)\r\n&gt;&gt;&gt; p = r.pubsub()\r\n</pre>\r\n<p>Once a PubSub instance is created, channels and patterns can be subscribed to.</p>\r\n<pre lang=\"pycon\">&gt;&gt;&gt; p.subscribe(\'my-first-channel\', \'my-second-channel\', ...)\r\n&gt;&gt;&gt; p.psubscribe(\'my-*\', ...)\r\n</pre>\r\n<p>The PubSub instance is now subscribed to those channels/patterns. The subscription confirmations can be seen by reading messages from the PubSub instance.</p>\r\n<pre lang=\"pycon\">&gt;&gt;&gt; p.get_message()\r\n{\'pattern\': None, \'type\': \'subscribe\', \'channel\': \'my-second-channel\', \'data\': 1L}\r\n&gt;&gt;&gt; p.get_message()\r\n{\'pattern\': None, \'type\': \'subscribe\', \'channel\': \'my-first-channel\', \'data\': 2L}\r\n&gt;&gt;&gt; p.get_message()\r\n{\'pattern\': None, \'type\': \'psubscribe\', \'channel\': \'my-*\', \'data\': 3L}\r\n</pre>\r\n<p>Every message read from a PubSub instance will be a dictionary with the following keys.</p>\r\n<ul>\r\n<li><strong>type</strong>: One of the following: \'subscribe\', \'unsubscribe\', \'psubscribe\', \'punsubscribe\', \'message\', \'pmessage\'</li>\r\n<li><strong>channel</strong>: The channel [un]subscribed to or the channel a message was published to</li>\r\n<li><strong>pattern</strong>: The pattern that matched a published message\'s channel. Will be None in all cases except for \'pmessage\' types.</li>\r\n<li><strong>data</strong>: The message data. With [un]subscribe messages, this value will be the number of channels and patterns the connection is currently subscribed to. With [p]message messages, this value will be the actual published message.</li>\r\n</ul>\r\n<p>Let\'s send a message now.</p>\r\n<pre lang=\"pycon\"># the publish method returns the number matching channel and pattern\r\n# subscriptions. \'my-first-channel\' matches both the \'my-first-channel\'\r\n# subscription and the \'my-*\' pattern subscription, so this message will\r\n# be delivered to 2 channels/patterns\r\n&gt;&gt;&gt; r.publish(\'my-first-channel\', \'some data\')\r\n2\r\n&gt;&gt;&gt; p.get_message()\r\n{\'channel\': \'my-first-channel\', \'data\': \'some data\', \'pattern\': None, \'type\': \'message\'}\r\n&gt;&gt;&gt; p.get_message()\r\n{\'channel\': \'my-first-channel\', \'data\': \'some data\', \'pattern\': \'my-*\', \'type\': \'pmessage\'}\r\n</pre>\r\n<p>Unsubscribing works just like subscribing. If no arguments are passed to [p]unsubscribe, all channels or patterns will be unsubscribed from.</p>\r\n<pre lang=\"pycon\">&gt;&gt;&gt; p.unsubscribe()\r\n&gt;&gt;&gt; p.punsubscribe(\'my-*\')\r\n&gt;&gt;&gt; p.get_message()\r\n{\'channel\': \'my-second-channel\', \'data\': 2L, \'pattern\': None, \'type\': \'unsubscribe\'}\r\n&gt;&gt;&gt; p.get_message()\r\n{\'channel\': \'my-first-channel\', \'data\': 1L, \'pattern\': None, \'type\': \'unsubscribe\'}\r\n&gt;&gt;&gt; p.get_message()\r\n{\'channel\': \'my-*\', \'data\': 0L, \'pattern\': None, \'type\': \'punsubscribe\'}\r\n</pre>\r\n<p>redis-py also allows you to register callback functions to handle published messages. Message handlers take a single argument, the message, which is a dictionary just like the examples above. To subscribe to a channel or pattern with a message handler, pass the channel or pattern name as a keyword argument with its value being the callback function.</p>\r\n<p>When a message is read on a channel or pattern with a message handler, the message dictionary is created and passed to the message handler. In this case, a None value is returned from get_message() since the message was already handled.</p>\r\n<pre lang=\"pycon\">&gt;&gt;&gt; def my_handler(message):\r\n...     print \'MY HANDLER: \', message[\'data\']\r\n&gt;&gt;&gt; p.subscribe(**{\'my-channel\': my_handler})\r\n# read the subscribe confirmation message\r\n&gt;&gt;&gt; p.get_message()\r\n{\'pattern\': None, \'type\': \'subscribe\', \'channel\': \'my-channel\', \'data\': 1L}\r\n&gt;&gt;&gt; r.publish(\'my-channel\', \'awesome data\')\r\n1\r\n# for the message handler to work, we need tell the instance to read data.\r\n# this can be done in several ways (read more below). we\'ll just use\r\n# the familiar get_message() function for now\r\n&gt;&gt;&gt; message = p.get_message()\r\nMY HANDLER:  awesome data\r\n# note here that the my_handler callback printed the string above.\r\n# `message` is None because the message was handled by our handler.\r\n&gt;&gt;&gt; print message\r\nNone\r\n</pre>\r\n<p>If your application is not interested in the (sometimes noisy) subscribe/unsubscribe confirmation messages, you can ignore them by passing ignore_subscribe_messages=True to r.pubsub(). This will cause all subscribe/unsubscribe messages to be read, but they won\'t bubble up to your application.</p>\r\n<pre lang=\"pycon\">&gt;&gt;&gt; p = r.pubsub(ignore_subscribe_messages=True)\r\n&gt;&gt;&gt; p.subscribe(\'my-channel\')\r\n&gt;&gt;&gt; p.get_message()  # hides the subscribe message and returns None\r\n&gt;&gt;&gt; r.publish(\'my-channel\')\r\n1\r\n&gt;&gt;&gt; p.get_message()\r\n{\'channel\': \'my-channel\', data\': \'my data\', \'pattern\': None, \'type\': \'message\'}\r\n</pre>\r\n<p>There are three different strategies for reading messages.</p>\r\n<p>The examples above have been using pubsub.get_message(). Behind the scenes, get_message() uses the system\'s \'select\' module to quickly poll the connection\'s socket. If there\'s data available to be read, get_message() will read it, format the message and return it or pass it to a message handler. If there\'s no data to be read, get_message() will immediately return None. This makes it trivial to integrate into an existing event loop inside your application.</p>\r\n<pre lang=\"pycon\">&gt;&gt;&gt; while True:\r\n&gt;&gt;&gt;     message = p.get_message()\r\n&gt;&gt;&gt;     if message:\r\n&gt;&gt;&gt;         # do something with the message\r\n&gt;&gt;&gt;     time.sleep(0.001)  # be nice to the system :)\r\n</pre>\r\n<p>Older versions of redis-py only read messages with pubsub.listen(). listen() is a generator that blocks until a message is available. If your application doesn\'t need to do anything else but receive and act on messages received from redis, listen() is an easy way to get up an running.</p>\r\n<pre lang=\"pycon\">&gt;&gt;&gt; for message in p.listen():\r\n...     # do something with the message\r\n</pre>\r\n<p>The third option runs an event loop in a separate thread. pubsub.run_in_thread() creates a new thread and starts the event loop. The thread object is returned to the caller of run_in_thread(). The caller can use the thread.stop() method to shut down the event loop and thread. Behind the scenes, this is simply a wrapper around get_message() that runs in a separate thread, essentially creating a tiny non-blocking event loop for you. run_in_thread() takes an optional sleep_time argument. If specified, the event loop will call time.sleep() with the value in each iteration of the loop.</p>\r\n<p>Note: Since we\'re running in a separate thread, there\'s no way to handle messages that aren\'t automatically handled with registered message handlers. Therefore, redis-py prevents you from calling run_in_thread() if you\'re subscribed to patterns or channels that don\'t have message handlers attached.</p>\r\n<pre lang=\"pycon\">&gt;&gt;&gt; p.subscribe(**{\'my-channel\': my_handler})\r\n&gt;&gt;&gt; thread = p.run_in_thread(sleep_time=0.001)\r\n# the event loop is now running in the background processing messages\r\n# when it\'s time to shut it down...\r\n&gt;&gt;&gt; thread.stop()\r\n</pre>\r\n<p>A PubSub object adheres to the same encoding semantics as the client instance it was created from. Any channel or pattern that\'s unicode will be encoded using the charset specified on the client before being sent to Redis. If the client\'s decode_responses flag is set the False (the default), the \'channel\', \'pattern\' and \'data\' values in message dictionaries will be byte strings (str on Python 2, bytes on Python 3). If the client\'s decode_responses is True, then the \'channel\', \'pattern\' and \'data\' values will be automatically decoded to unicode strings using the client\'s charset.</p>\r\n<p>PubSub objects remember what channels and patterns they are subscribed to. In the event of a disconnection such as a network error or timeout, the PubSub object will re-subscribe to all prior channels and patterns when reconnecting. Messages that were published while the client was disconnected cannot be delivered. When you\'re finished with a PubSub object, call its .close() method to shutdown the connection.</p>\r\n<pre lang=\"pycon\">&gt;&gt;&gt; p = r.pubsub()\r\n&gt;&gt;&gt; ...\r\n&gt;&gt;&gt; p.close()\r\n</pre>\r\n<p><a name=\"user-content-lua-scripting\"></a></p>\r\n<h3><a id=\"user-content-lua-scripting\" class=\"anchor\" href=\"https://github.com/andymccurdy/redis-py#lua-scripting\"></a>LUA Scripting</h3>\r\n<p>redis-py supports the EVAL, EVALSHA, and SCRIPT commands. However, there are a number of edge cases that make these commands tedious to use in real world scenarios. Therefore, redis-py exposes a Script object that makes scripting much easier to use.</p>\r\n<p>To create a Script instance, use the register_script function on a client instance passing the LUA code as the first argument. register_script returns a Script instance that you can use throughout your code.</p>\r\n<p>The following trivial LUA script accepts two parameters: the name of a key and a multiplier value. The script fetches the value stored in the key, multiplies it with the multiplier value and returns the result.</p>\r\n<pre lang=\"pycon\">&gt;&gt;&gt; r = redis.StrictRedis()\r\n&gt;&gt;&gt; lua = \"\"\"\r\n... local value = redis.call(\'GET\', KEYS[1])\r\n... value = tonumber(value)\r\n... return value * ARGV[1]\"\"\"\r\n&gt;&gt;&gt; multiply = r.register_script(lua)\r\n</pre>\r\n<p>multiply is now a Script instance that is invoked by calling it like a function. Script instances accept the following optional arguments:</p>\r\n<ul>\r\n<li><strong>keys</strong>: A list of key names that the script will access. This becomes the KEYS list in LUA.</li>\r\n<li><strong>args</strong>: A list of argument values. This becomes the ARGV list in LUA.</li>\r\n<li><strong>client</strong>: A redis-py Client or Pipeline instance that will invoke the script. If client isn\'t specified, the client that intiially created the Script instance (the one that register_script was invoked from) will be used.</li>\r\n</ul>\r\n<p>Continuing the example from above:</p>\r\n<pre lang=\"pycon\">&gt;&gt;&gt; r.set(\'foo\', 2)\r\n&gt;&gt;&gt; multiply(keys=[\'foo\'], args=[5])\r\n10\r\n</pre>\r\n<p>The value of key \'foo\' is set to 2. When multiply is invoked, the \'foo\' key is passed to the script along with the multiplier value of 5. LUA executes the script and returns the result, 10.</p>\r\n<p>Script instances can be executed using a different client instance, even one that points to a completely different Redis server.</p>\r\n<pre lang=\"pycon\">&gt;&gt;&gt; r2 = redis.StrictRedis(\'redis2.example.com\')\r\n&gt;&gt;&gt; r2.set(\'foo\', 3)\r\n&gt;&gt;&gt; multiply(keys=[\'foo\'], args=[5], client=r2)\r\n15\r\n</pre>\r\n<p>The Script object ensures that the LUA script is loaded into Redis\'s script cache. In the event of a NOSCRIPT error, it will load the script and retry executing it.</p>\r\n<p>Script objects can also be used in pipelines. The pipeline instance should be passed as the client argument when calling the script. Care is taken to ensure that the script is registered in Redis\'s script cache just prior to pipeline execution.</p>\r\n<pre lang=\"pycon\">&gt;&gt;&gt; pipe = r.pipeline()\r\n&gt;&gt;&gt; pipe.set(\'foo\', 5)\r\n&gt;&gt;&gt; multiply(keys=[\'foo\'], args=[5], client=pipe)\r\n&gt;&gt;&gt; pipe.execute()\r\n[True, 25]\r\n</pre>\r\n<p><a name=\"user-content-sentinel-support\"></a></p>\r\n<h3><a id=\"user-content-sentinel-support\" class=\"anchor\" href=\"https://github.com/andymccurdy/redis-py#sentinel-support\"></a>Sentinel support</h3>\r\n<p>redis-py can be used together with <a href=\"http://redis.io/topics/sentinel\">Redis Sentinel</a> to discover Redis nodes. You need to have at least one Sentinel daemon running in order to use redis-py\'s Sentinel support.</p>\r\n<p>Connecting redis-py to the Sentinel instance(s) is easy. You can use a Sentinel connection to discover the master and slaves network addresses:</p>\r\n<pre lang=\"pycon\">&gt;&gt;&gt; from redis.sentinel import Sentinel\r\n&gt;&gt;&gt; sentinel = Sentinel([(\'localhost\', 26379)], socket_timeout=0.1)\r\n&gt;&gt;&gt; sentinel.discover_master(\'mymaster\')\r\n(\'127.0.0.1\', 6379)\r\n&gt;&gt;&gt; sentinel.discover_slaves(\'mymaster\')\r\n[(\'127.0.0.1\', 6380)]\r\n</pre>\r\n<p>You can also create Redis client connections from a Sentinel instance. You can connect to either the master (for write operations) or a slave (for read-only operations).</p>\r\n<pre lang=\"pycon\">&gt;&gt;&gt; master = sentinel.master_for(\'mymaster\', socket_timeout=0.1)\r\n&gt;&gt;&gt; slave = sentinel.slave_for(\'mymaster\', socket_timeout=0.1)\r\n&gt;&gt;&gt; master.set(\'foo\', \'bar\')\r\n&gt;&gt;&gt; slave.get(\'foo\')\r\n\'bar\'\r\n</pre>\r\n<p>The master and slave objects are normal StrictRedis instances with their connection pool bound to the Sentinel instance. When a Sentinel backed client attempts to establish a connection, it first queries the Sentinel servers to determine an appropriate host to connect to. If no server is found, a MasterNotFoundError or SlaveNotFoundError is raised. Both exceptions are subclasses of ConnectionError.</p>\r\n<p>When trying to connect to a slave client, the Sentinel connection pool will iterate over the list of slaves until it finds one that can be connected to. If no slaves can be connected to, a connection will be established with the master.</p>\r\n<p>See <a href=\"http://redis.io/topics/sentinel-clients\">Guidelines for Redis clients with support for Redis Sentinel</a> to learn more about Redis Sentinel.</p>\r\n<p><a name=\"user-content-scan-iterators\"></a></p>\r\n<h3><a id=\"user-content-scan-iterators\" class=\"anchor\" href=\"https://github.com/andymccurdy/redis-py#scan-iterators\"></a>Scan Iterators</h3>\r\n<p>The *SCAN commands introduced in Redis 2.8 can be cumbersome to use. While these commands are fully supported, redis-py also exposes the following methods that return Python iterators for convenience: scan_iter, hscan_iter, sscan_iter and zscan_iter.</p>\r\n<pre lang=\"pycon\">&gt;&gt;&gt; for key, value in ((\'A\', \'1\'), (\'B\', \'2\'), (\'C\', \'3\')):\r\n...     r.set(key, value)\r\n&gt;&gt;&gt; for key in r.scan_iter():\r\n...     print key, r.get(key)\r\nA 1\r\nB 2\r\nC 3\r\n</pre>\r\n<p><a name=\"user-content-author\"></a></p>\r\n<h3><a id=\"user-content-author\" class=\"anchor\" href=\"https://github.com/andymccurdy/redis-py#author\"></a>Author</h3>\r\n<p>redis-py is developed and maintained by Andy McCurdy (<a href=\"mailto:sedrik@gmail.com\">sedrik@gmail.com</a>). It can be found here:<a href=\"http://github.com/andymccurdy/redis-py\">http://github.com/andymccurdy/redis-py</a></p>\r\n<p>Special thanks to:</p>\r\n<ul>\r\n<li>Ludovico Magnocavallo, author of the original Python Redis client, from which some of the socket code is still used.</li>\r\n<li>Alexander Solovyov for ideas on the generic response callback system.</li>\r\n<li>Paul Hubbard for initial packaging support.</li>\r\n</ul>','andymccurdy','2015-11-02 23:08:00',7),(19,'python函数重载','<p>写过Java的同学都知道函数是可以用来重载的，实现方法就是相同的函数名，不同类型或不同个数的函数形参，例如add实现两个数值相加，就可以这样实现：</p>\r\n<pre>public static int add(int num1, int num2){<br /> return num1+num2;<br />}<br />public static float add(float num1, float num2){<br /> return num1+num2;<br />}<br /><br /></pre>\r\n<p>使用时：</p>\r\n<pre>System.out.println(test.add(1.1f, 1.2f));<br />System.out.println(test.add(1, 1));</pre>\r\n<p>而在python中，函数的重载是通过默认参数来实现的：</p>\r\n<pre>def add(num1, num2=0, num3=0):<br />return num1 + num2 + num3<br />print add(1)<br />print add(1, 2)<br />print add(1, 2, 3)</pre>\r\n<p>同理，java中的构造函数可能根据参数不同需要重载，而python中对__init__进行重载的方式也是设置默认值，例子如下：</p>\r\n<pre>def __init__(self, id=None, title=None, content=None, author=None, create_time=None, category=None, tags=None):<br />    self.id = id<br />    self.title = title<br />    self.content = content<br />    self.author = author<br />    self.category = category<br />    self.tags = tags<br />    self.create_time = datetime.strptime(create_time, \"%Y-%m-%d %H:%M:%S\")</pre>','努力的Coder','2015-11-05 14:49:00',5),(20,'__str__,  __repr__ , eval','<p>覆盖__str__方法，返回的字符串是可读的，类似与Java中覆盖toString方法．</p>\r\n<p>而__repr__方法返回的是python内部表示用的字符串，一般通过eval(repr(something)) == something，这是约定，但不代表必须要这样实现．当调用repr(something)时，调用的就是__repr__方法．</p>\r\n<p>当调用print或者需要将对象转换为字符串时，首先调用__str__方法得到返回的内容，如果没有覆盖__str__ 方法，则会去找__repr__方法返回的内容．</p>\r\n<p>eval(param)用来将字符串转换为python的内部对象，例如eval(\'1+1\')就会得到２</p>\r\n<p>下面给出一个例子：</p>\r\n<pre>class Person(object):<br /><br />    def __init__(self, name, age):<br />&nbsp; &nbsp;     self.name = name<br />&nbsp; &nbsp;     self.age = age<br /><br />     def __str__(self):<br />&nbsp; &nbsp;      return \'Name:%s, age:%d\' % (self.name, self.age)</pre>\r\n<pre>p = Person(\"Brian\", 21)<br />print p</pre>\r\n<p>输出结果是：<code>Name:Brian, age:21</code><br />重新定义类为:</p>\r\n<pre>class Person(object):<br /><br />    def __init__(self, name, age):<br />         self.name = name<br />         self.age = age<br /><br />     def __repr__(self):<br />         return \'Person(\"%s\",%d)\' % (self.name, self.age)</pre>\r\n<p>同样的步骤，输出结果为：<code>Person(\"Brian\",21)</code><br />修改Person声明为：</p>\r\n<pre>class Person(object):<br /><br />    def __init__(self, name, age):<br />        self.name = name<br />        self.age = age<br /><br />    def __str__(self):<br />        return \'Name:%s, age:%d\' % (self.name, self.age)<br /><br />    def __repr__(self):<br />        return \'Person(\"%s\",%d)\' % (self.name, self.age)</pre>\r\n<p>输出结果为<code>Name:Brian, age:21</code><br />证实了上面关于__str__和__repr__优先级的说法.</p>\r\n<p>在生产中，将对象进行缓存，可以提高效率，这里以redis为例，说明如何存储和取出对象．首先要说明一点就是在redis中的值都是字符串类型的．</p>\r\n<pre>p = Person(\"Brian\", 21)<br />r.set(\"brian\", p)　　＃r是redis_client<br />person = r.get(\"brian\")<br />print type(person)<br />print person</pre>\r\n<p>输出是：</p>\r\n<pre>Name:Brian, age:21<br />&lt;type \'str\'&gt;</pre>\r\n<p>这也验证了，当需要将对象转换为字符串时，得到的是__str__的返回值<br />通过redis得到的值是str类型的，对这个str调用eval,会得到错误提示：</p>\r\n<pre>File \"&lt;string&gt;\", line 1<br />Name:Brian, age:21<br /> ^<br />SyntaxError: invalid syntax</pre>\r\n<p>而在__repr__的定义中，返回的是\'Person(\"%s\",%d)\' % (self.name, self.age)说白了就是构造一个对象语句的字符串形式，在往redis中存储时，通过repr(p)可以得到这个字符串，如下：</p>\r\n<pre>p = Person(\"Brian\", 21)<br />r.set(\"brian\", repr(p))<br />person = eval(r.get(\"brian\"))　　＃通过eval相当于执行person = Person(\"Brian\",21)<br />print type(person)<br />print person</pre>\r\n<p>输出为：</p>\r\n<pre>&lt;class \'__main__.Person\'&gt;<br />Name:Brian, age:21</pre>\r\n<p>通过repr和eval的配合完成了对象在redis中的存取.</p>','努力的Coder','2015-11-05 17:06:00',5),(21,'SQLAlchemy对象使用redis缓存','<p><a title=\"这里介绍了如何使用redis对对象进行缓存\" href=\"../../../article/detail/20/\" target=\"_blank\">这里介绍了如何使用redis对对象进行缓存</a></p>\r\n<p>在使用SQLAlchemy时，同样想到了使用相同的方法对model进行缓存，model的定义如下：</p>\r\n<pre>class Article(Base):<br />    __tablename__ = \'article\'<br /><br />    id = Column(Integer, primary_key=True)<br />    title = Column(String(256))<br />    content = Column(Text)<br />    author = Column(String(16))<br />    create_time = Column(DateTime)<br />    tags = relationship(\'Tag\', secondary=article_tag, backref=\'article\')<br />    category = Column(Integer, ForeignKey(\'category.id\'))</pre>\r\n<p>上面的Article就是一个典型的SQLAlchemy模型的定义．为了能够交给redis缓存，根据上篇文章的介绍，为这个类添加两个方法：</p>\r\n<pre>def __init__(self, id=None, title=None, content=None, author=None, create_time=None, category=None, tags=None):<br />    self.id = id<br />    self.title = title<br />    self.content = content<br />    self.author = author<br />    self.category = category<br />    self.tags = tags<br />    self.create_time = datetime.strptime(create_time, \"%Y-%m-%d %H:%M:%S\")<br /><br />def __repr__(self):<br />    return \'Article(%d,\"\"\"%s\"\"\",\"\"\"%s\"\"\", \"%s\",\"%s\", %d, %s)\' % (<br />        self.id, self.title, self.content, self.author, self.create_time, self.category, self.tags)</pre>\r\n<p>添加__repr__是定义了将对象存储到redis中时value的格式，其内容就是声明一个对象的字符串形式，方便使用eval进行还原，而__repr__返回的字符串在eval时需要一个带有参数的__init__函数．</p>\r\n<p>在使用时代码如下：</p>\r\n<pre>redis_key = article_detail_redis_key + \':\' + article_id<br />article, category = redis_client.hmget(redis_key, \'article\', \'category\')<br />if not article:<br />    session = Session()<br />    article, category = session.query(Article, Category.name).join(Category).filter(<br />        Article.id == article_id).first()<br />    article.content = re.sub(\"\\\"\\\"\\\"\", r\'＂＂＂\', article.content)<br />    article.title = re.sub(\"\\\"\\\"\\\"\", r\'＂＂＂\', article.title)<br />    redis_client.hmset(redis_key, {\'article\': article, \'category\': category})<br />    redis_client.expire(redis_key, article_detail_expire_time)<br />    session.close()<br />else:<br />    article = eval(article)<br />return article, category</pre>\r\n<p>这样，可以完成对SQLAlchemy model的缓存操作，但是在使用Flask_Admin在后台编辑保存时提示:</p>\r\n<p>TypeError<br />TypeError: Incompatible collection type: None is not list-like</p>\r\n<p>查找问题之后，才明白，是因为Flask_admin保存对象时，调用的是默认的__init__方法，也就是说并没有往__init__的参数中赋值，而是在随后的处理中，进行赋值，就是先初始化，后赋值．那么我们重载的这个__init__方法，这几个参数都会被设置为None.而我们对create_time这种变量还进行了处理，如果去掉create_time这种字段，保存时不会出错，但是当从redis中获取到字符串并eval试图构建对象时，就会有各种问题．</p>\r\n<p>为了解决这个问题，有效的利用redis缓存带来的性能提升，找到了一个合适的方法解决这个问题，暂且称它为＂创建一个镜像类＂，也就是说创造一个跟这个model字段一模一样的类，只是不去继承SQLAlchemy的语义，定义如下：</p>\r\n<pre>class ArticleRedis(object):<br />    def __init__(self, id, title, content, author, create_time, tags, category_id):<br />        self.id = id<br />        self.title = title<br />        self.content = content<br />        self.author = author<br />        self.create_time = create_time<br />        self.tags = tags<br />        self.category = category_id</pre>\r\n<p>使用时：</p>\r\n<pre>redis_key = article_detail_redis_key + \':\' + article_id<br />(art_id, article_title, article_content, article_author, article_create_time, article_tags, article_category_id,<br /> article_category_name) = redis_client.hmget(<br />    redis_key, \'id\', \'title\', \'content\', \'author\', \'create_time\', \'tags\', \'category_id\', \'category_name\')<br />if not art_id:<br />    session = Session()<br />    article, category = session.query(Article, Category.name).join(Category).filter(<br />        Article.id == article_id).first()<br />    article.content = re.sub(\"\\\"\\\"\\\"\", r\'＂＂＂\', article.content)<br />    article.title = re.sub(\"\\\"\\\"\\\"\", r\'＂＂＂\', article.title)<br />    redis_client.hmset(redis_key, {\'id\': article.id, \'title\': article.title, \'content\': article.content,<br />                                   \'author\': article.author, \'create_time\': article.create_time,<br />                                   \'tags\': article.tags, \'category_id\': article.category,<br />                                   \'category_name\': category})<br />    redis_client.expire(redis_key, article_detail_expire_time)<br />    session.close()<br />else:<br />    article = ArticleRedis(art_id, article_title, article_content, article_author, article_create_time,<br />                           article_tags, article_category_id)<br />    category = article_category_name<br />return article, category</pre>\r\n<p>这样通过镜像就完美的解决了问题．</p>\r\n<p>不使用redis访问时，请求响应时间为：</p>\r\n<p><em>[06/Nov/2015:06:14:12 +0000] \"GET /article/detail/21/ HTTP/1.1\" 200 11342 \"http://www.trytofix.com/category/python/1/\" \"Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Ubuntu Chromium/39.0.2171.65 Chrome/39.0.2171.65 Safari/537.36\" 31ms</em></p>\r\n<p>访问缓存过的同一页面时，请求响应时间为:</p>\r\n<p><em>[06/Nov/2015:06:14:15 +0000] \"GET /article/detail/21/ HTTP/1.1\" 200 11342 \"http://www.trytofix.com/category/python/1/\" \"Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Ubuntu Chromium/39.0.2171.65 Chrome/39.0.2171.65 Safari/537.36\" 6ms</em></p>\r\n<p>可以看出，使用redis不仅降低了对数据库的压力，也加快了程序的响应时间．</p>','努力的Coder','2015-11-06 13:50:00',5),(22,'Flask，uwsgi，Nginx配合使用提供web服务','<p>Flask是许多python初学者的首选框架，相比Django这种重量级的怪兽而言，Flask配置简单，提供了web应用的核心功能，对于orm，模板引擎等扩展功能通过插件的形式集成，本站也是使用Flask进行开发。</p>\r\n<p>Flask通过werkzeug实现了wsgi协议，而uwsgi作为实现了wsgi协议的应用服务器，可以通过多线程的worker提供更高的并发请求处理。</p>\r\n<p>Nginx作为反向代理服务器提供了负载均衡功能，通过location可以优化对静态文件的访问。</p>\r\n<p>Flask+uwsgi+Nginx是一个web应用+web应用服务器+反向代理服务器的经典组合，网上关于这三者组合的帖子有很多，大都千篇一律，在部署时，遇到了不少坑，很多帖子的配置并不生效，通过参考这些帖子，以及各种搜索之后，找到了一个可以使用的配置，仅供参考。</p>\r\n<p>首先是web应用的入口文件web_main.py，定义了app的文件，内容如下：</p>\r\n<pre>from flask import Flask<br /><br />app = Flask(__name__)</pre>\r\n<p>uwsgi的配置文件conf/uwsgi.conf内容如下：</p>\r\n<pre>[uwsgi]<br />socket = 127.0.0.1:8077<br />master = true<br />module = web_main:app<br />daemonize = logs/access.log<br />processes = 3<br />enable-threads = true<br />need-app = true<br />threads = 8<br />max-requests = 10000<br />memory-report = true<br />harakiri = 6<br />pidfile = pidfile<br />buffer-size = 4096<br />post-buffering = 8192<br />http-keepalive = 100<br />log-format = %(addr) - %(user) [%(ltime)] \"%(method) %(uri) %(proto)\" %(status) %(size) \"%(referer)\" \"%(uagent)\" %(msecs)ms<br />logto = logs/blog.log<br />touch-logreopen = logs/.touch_log_rotate.tmp<br />reload-mercy = 8</pre>\r\n<pre>在uwsgi.conf配置中，通过module = web_main:app将Flask与uwsgi结合在了一起，通过socket = 127.0.0.1:8077表明通过unix socket进行通信，端口是8077,如果这里使用的是http = 127.0.0.1:8077，则可以处理http请求，在这里，是只能响应socket请求。</pre>\r\n<pre>nginx的配置是在/etc/nginx/sites-available/default (Ubuntu系统)中，声明如下：</pre>\r\n<pre>server {<br /> listen 80;<br /> server_name www.trytofix.com;<br /><br /> location / {<br /> include /etc/nginx/uwsgi_params;<br /> uwsgi_pass 127.0.0.1:8077;<br /><br /> }<br /><br /> location ^~/static/ {<br /> root /home/q/blog;<br /> }</pre>\r\n<p>nginx监听80端口，对于/static/开头的请求直接定位到了文件夹，比如www.trytofix.com/static/bootstrap.css通过nginx时，nginx就会直接去/home/q/blog下去取bootstrap.css这个文件，这样就不需要再通过Flask处理并返回，优化了对静态资源的处理。</p>\r\n<p>重点是location / {}中的内容，uwsgi_pass说明了将请求发送给本机的监听8077端口的uwsgi服务器进行处理，网上关于uwsgi配置的参数有一大把，需要的话可以去参考下。</p>\r\n<p>上面的简单配置可以保证一个Flask_uwsgi_Nginx构成的系统成功的运行起来。</p>','努力的Coder','2015-11-08 22:27:00',5),(23,'Nginx实现301跳转','<p>在浏览器中输入http://trytofix.com会自动跳转到http://www.trytofix.com</p>\r\n<p>同样输入http://trytofix.com/article/detail/22/就会跳转到http://www.trytofix.com/article/detail/22/</p>\r\n<p>访问http://trytofix.com的时候相应头是：</p>\r\n<pre>Request URL:http://trytofix.com/ Request Method:GET Status Code:301 Moved Permanently</pre>\r\n<p>301永久重定向用来告诉请求者当前请求被永久的指向了另一个请求.</p>\r\n<p>这么做的好处是保证了一个页面对应一个url，在流量统计和SEO时，会带来很大的方便。</p>\r\n<p>很多cdn服务商提供了301跳转，同样的，也可以通过服务器的Nginx实现301永久跳转。</p>\r\n<p>域名trytofix.com对应了一个www解析www.trytofix.com和一个@解析trytofix.com，为了让trytofix.com的所有请求都重定向到www.trytofix.com上，在Nginx的配置如下：</p>\r\n<pre>server {<br /> listen 80;<br /> server_name trytofix.com;<br /> rewrite ^ http://www.trytofix.com$request_uri? permanent;<br />}</pre>\r\n<p>这就是本站的301跳转的基本配置。使用这个配置，可以实现301的永久跳转。</p>','努力的Coder','2015-11-09 00:01:00',8),(24,'反向索引（Inverted Index）','<p>反向索引是一种索引结构，它存储了单词与单词自身在一个或多个文档中所在位置之间的映射。反向索引通常利用关联数组实现。它拥有两种表现形式：</p>\r\n<ol>\r\n<li><em>inverted file index</em>，其表现形式为 {单词，单词所在文档的ID}</li>\r\n<li><em>full inverted index，</em>其表现形式为{单词，（单词所在文档的ID，在具体文档中的位置）}</li>\r\n</ol>\r\n<p>具体实例，假设有三个文档：</p>\r\n<ul>\r\n<li><span class=\"texhtml\"><em>T</em><sub>0</sub> =</span> <code>\"it is what it is\"</code></li>\r\n<li><span class=\"texhtml\"><em>T</em><sub>1</sub> =</span> <code>\"what is it\"</code></li>\r\n<li><span class=\"texhtml\"><em>T</em><sub>2</sub> =</span> <code>\"it is a banana\"</code></li>\r\n</ul>\r\n<p>那么，采用inverted file index方式，结果是：<br />\"a\": {2}<br />\"banana\": {2}<br />\"is\": {0, 1, 2}<br />\"it\": {0, 1, 2}<br />\"what\": {0, 1}<br />采用full inverted index方式，结果是：</p>\r\n<pre>\"a\":      {(2, 2)}<br />\"banana\": {(2, 3)}<br />\"is\":     {(0, 1), (0, 4), <strong>(1, 1)</strong>, (2, 1)}<br />\"it\":     {(0, 0), (0, 3), <strong>(1, 2)</strong>, (2, 0)}<br />\"what\":   {(0, 2), <strong>(1, 0)</strong>}</pre>','http://zhangyu8374.iteye.com/blog/86307','2015-12-04 11:49:00',10),(25,'修改表结构','<p>修改字段数据长度：</p>\r\n<p><code>alter table article modify column author varchar(64);</code></p>\r\n<p>修改字段数据类型：</p>\r\n<p><code>;alter table flight modify flight_number int(10);</code></p>\r\n<p>注意修改数据类型和长度后对原有数据的影响．</p>','努力的Coder','2015-12-04 12:13:00',11),(26,'json.dumps编码问题','<p>Python 使用json模块生成json字符串时，默认会输出为unicode格式．例如：</p>\r\n<pre>import json<br />a = \'我是程序员\'<br />print json.dumps(a) </pre>\r\n<p>输出为：</p>\r\n<pre>\"\\u6211\\u662f\\u7a0b\\u5e8f\\u5458\"</pre>\r\n<p>为了禁止python进行自动编码，通过s,ensure_ascii=False即可实现：</p>\r\n<p>结果如下：</p>\r\n<pre>print json.dumps(s,ensure_ascii=False)<code><br /></code></pre>\r\n<p>输出为：\"我是程序员\"</p>','努力的Coder','2015-12-04 14:21:00',5),(27,'Python获取某年某月的总天数以及月份的第一天是星期几','<p><font color=\"#222222\">使用calendar模块</font></p>\r\n<p><font color=\"#222222\">calendar.monthrange(year, month)</font><br /><font color=\"#222222\">Returns weekday of first day of the month and number of days in month, for the specified year and month.</font></p>\r\n<p><font color=\"#222222\">例子如下：</font></p>\r\n<pre>&gt;&gt;&gt; import calendar\r\n&gt;&gt;&gt; now_year=2012\r\n&gt;&gt;&gt; now_month=7\r\n\r\n&gt;&gt;&gt; calendar.monthrange(now_year,now_month)\r\n(6, 31)\r\n&gt;&gt;&gt; calendar.monthrange(now_year,now_month)[1]\r\n31\r\n</pre>\r\n<p>calendar.monthrange返回一个包含两个元素的元组，元组中的第一个数字是某年某月第一天是星期几,范围是0－＞6 对应着星期一－＞星期日,第二个数字是某年某月包含的天数．</p>\r\n<p>上面例子中的结果(6,31)意味着2012年7月一共有31天，并且2012年7月1日是星期日.</p>','努力的Coder','2015-12-04 14:35:00',5),(28,'使用python timeit验证re.compile预编译对正则表达式效率的影响','<p>最近遇到接口请求时超时太多，在优化代码时，首先想到的是会不会是因为正则表达式使用的太频繁，基本都是直接使用re.match，官网文档说通过预编译re.compile处理正则表达式可以提高效率,但是对于预编译后的效率提升多少，并没有进行实验，而是先通过网络进行查找，并没有太满意的答案，众说纷纭，于是决定自己来验证，使用python自带的timeit参数，timeit可以用来检测某小段代码的执行时间，原理就是通过重复执行计算平均时间。</p>\r\n<div class=\"code panel\">\r\n<div class=\"codeContent panelContent\">\r\n<pre class=\"code-java\"> python -m timeit -s <span class=\"code-quote\">\"<span class=\"code-keyword\">import</span> re\"</span> <span class=\"code-quote\">\"r=re.compile(r\'hello\')\"</span> <span class=\"code-quote\">\"r.match(\'helloword\')\"</span>\r\n</pre>\r\n</div>\r\n</div>\r\n<p>-s 之后就是python 语句，都是用空格分隔</p>\r\n<p>这个是先编译的正则表达式，随后再进行匹配</p>\r\n<div class=\"code panel\">\r\n<div class=\"codeContent panelContent\">\r\n<pre class=\"code-java\">python -m timeit -s <span class=\"code-quote\">\"<span class=\"code-keyword\">import</span> re\"</span> <span class=\"code-quote\">\"re</span><span class=\"code-quote\">.match(\'hello\',\'helloword\')\"</span>\r\n</pre>\r\n</div>\r\n</div>\r\n<p>而这个就是不进行预编译的语句。</p>\r\n<p>预编译正则执行的结果是：</p>\r\n<pre>1000000 loops, best of 3: 0.828 usec per loop<br />1000000 loops, best of 3: 0.829 usec per loop</pre>\r\n<p>直接使用re.match的结果是：</p>\r\n<pre>1000000 loops, best of 3: 0.835 usec per loop<br />1000000 loops, best of 3: 0.837 usec per loop</pre>\r\n<p>执行相同的正则表达式时，虽然每次运行时间不太相同，但预编译的总比不预编译的执行要快一些。</p>\r\n<p>re.match定义如下：</p>\r\n<div class=\"code panel\">\r\n<div class=\"codeContent panelContent\">\r\n<pre class=\"code-java\">def match(pattern, string, flags=0):\r\n    \"\"\"Try to apply the pattern at the start of the string, returning\r\n    a match object, or None <span class=\"code-keyword\">if</span> no match was found.\"\"\"\r\n    <span class=\"code-keyword\">return</span> _compile(pattern, flags).match(string)</pre>\r\n</div>\r\n</div>\r\n<p>re.compile定义：</p>\r\n<div class=\"code panel\">\r\n<div class=\"codeContent panelContent\">\r\n<pre class=\"code-java\">def compile(pattern, flags=0):\r\n    <span class=\"code-quote\">\"Compile a regular expression pattern, returning a pattern object.\"</span>\r\n    <span class=\"code-keyword\">return</span> _compile(pattern, flags)</pre>\r\n</div>\r\n</div>\r\n<p>_compile定义：</p>\r\n<div class=\"code panel\">\r\n<div class=\"codeContent panelContent\">\r\n<pre class=\"code-java\">def _compile(*key):\r\n    # internal: compile pattern\r\n    pattern, flags = key\r\n    bypass_cache = flags &amp; DEBUG\r\n    <span class=\"code-keyword\">if</span> not bypass_cache:\r\n        cachekey = (type(key[0]),) + key\r\n        p = _cache.get(cachekey)\r\n        <span class=\"code-keyword\">if</span> p is not None:\r\n            <span class=\"code-keyword\">return</span> p\r\n    <span class=\"code-keyword\">if</span> isinstance(pattern, _pattern_type):\r\n        <span class=\"code-keyword\">if</span> flags:\r\n            raise ValueError(\'Cannot process flags argument with a compiled pattern\')\r\n        <span class=\"code-keyword\">return</span> pattern\r\n    <span class=\"code-keyword\">if</span> not sre_compile.isstring(pattern):\r\n        raise TypeError, <span class=\"code-quote\">\"first argument must be string or compiled pattern\"</span>\r\n    <span class=\"code-keyword\">try</span>:\r\n        p = sre_compile.compile(pattern, flags)\r\n    except error, v:\r\n        raise error, v # invalid expression\r\n    <span class=\"code-keyword\">if</span> not bypass_cache:\r\n        <span class=\"code-keyword\">if</span> len(_cache) &gt;= _MAXCACHE:\r\n            _cache.clear()\r\n        _cache[cachekey] = p\r\n    <span class=\"code-keyword\">return</span> p</pre>\r\n</div>\r\n</div>\r\n<p>re.match先调用了_compile缓存正则对象，再进行match操作. re.compile也调用了_compile,将正则对象缓存起来。这个缓存的大小是100．</p>\r\n<p>re.match()相比re.compile().match()多了一次在内存中读取缓存的操作，当正则表达式数量在缓存的大小(默认100)之内时，re.match读取缓存的命中率高，两者性能差别并不明显．但预编译要优于直接re.match().</p>\r\n<p>当正则表达式数量很多时，测试如下：</p>\r\n<p>使用预编译：</p>\r\n<pre>python -m timeit -n 100000 -s \"import re\" \"import random\" \"r=re.compile(\'%s\' % (random.randint(100,1000000)))\" \"r.match(\'helloword\')\"</pre>\r\n<p>执行效率如下：</p>\r\n<pre>100000 loops, best of 3: 26.6 usec per loop　(第一次)<br />100000 loops, best of 3: 25.5 usec per loop　(第二次)</pre>\r\n<p>直接使用re.match():</p>\r\n<pre>python -m timeit -n 100000 -s \"import re\" \"import random\" \"re.match(\'%s\' % (random.randint(100,1000000)),\'helloword\')\"</pre>\r\n<p>执行效率如下：</p>\r\n<pre>100000 loops, best of 3: 26 usec per loop (第一次)<br />100000 loops, best of 3: 25.6 usec per loop (第二次)</pre>\r\n<p>可见，当正则量较大时，使用re.match效率与使用re.compile效率会因具体的环境而不确定．</p>\r\n<p>所以可以得出结论，如果正则表达式数量不多的情况下，使用re.compile会带来性能的略微提升，当正则表达式量很大时，使用re.match与re.compile旗鼓相当．</p>','努力的Coder','2015-12-04 14:56:00',5),(29,'python timedelta','<p>datetime.timedelta对象代表两个时间之间的的时间差，两个date或datetime对象相减时可以返回一个timedelta对象。<br />构造函数：<br />class&nbsp;datetime.timedelta([days[,&nbsp;seconds[,&nbsp;microseconds[,&nbsp;milliseconds[,&nbsp;minutes[,&nbsp;hours[,&nbsp;weeks]]]]]]])<br />所有参数可选，且默认都是0，参数的值可以是整数，浮点数，正数或负数。<br />内部只存储days，seconds，microseconds，其他参数的值会自动按如下规则抓转换：</p>\r\n<p>1 millisecond（毫秒） 转换成 1000 microseconds（微秒）<br />1 minute 转换成 60 seconds<br />1 hour 转换成 3600 seconds<br />1 week转换成 7 days<br />三个参数的取值范围分别为：</p>\r\n<p>0&nbsp;&lt;=&nbsp;microseconds&nbsp;&lt;&nbsp;1000000<br />0&nbsp;&lt;=&nbsp;seconds&nbsp;&lt;&nbsp;3600*24&nbsp;(the number of seconds in one day)<br />-999999999&nbsp;&lt;=&nbsp;days&nbsp;&lt;=&nbsp;999999999<br />如果任意参数是float，且小数点后含有microseconds部分，那么microseconds的值为所有参数的微秒部分的总和（四舍五入）如：<br />Python代码&nbsp;&nbsp;</p>\r\n<pre>&gt;&gt;&gt;&nbsp;datetime.timedelta(hours=1.232,seconds=20).microseconds&nbsp;&nbsp;<br />200000&nbsp;&nbsp;<br />&gt;&gt;&gt;&nbsp;datetime.timedelta(hours=1.232,seconds=20.3).microseconds&nbsp;&nbsp;<br />500000&nbsp;&nbsp;</pre>\r\n<p>支持的操作有：</p>\r\n<p>1&nbsp;=&nbsp;t2&nbsp;+&nbsp;t3<br />两个timedelta对象相加，同时满足&nbsp;t1-t2&nbsp;==&nbsp;t3&nbsp;and&nbsp;t1-t3&nbsp;==&nbsp;t2&nbsp;为True<br />t1&nbsp;=&nbsp;t2&nbsp;-&nbsp;t3<br />两个timedelta对象相减， 同时满足&nbsp;t1&nbsp;==&nbsp;t2&nbsp;-&nbsp;t3&nbsp;and&nbsp;t2&nbsp;==&nbsp;t1&nbsp;+&nbsp;t3 为True<br />t1&nbsp;=&nbsp;t2&nbsp;&nbsp;i&nbsp;or&nbsp;t1&nbsp;=&nbsp;i&nbsp;&nbsp;t2<br />timedelta对象分别乘以i 同时满足&nbsp;t1&nbsp;// i ==&nbsp;t2&nbsp;为True, 且&nbsp;i&nbsp;!=&nbsp;0<br />t1&nbsp;=&nbsp;t2&nbsp;//&nbsp;i<br />向下取整，余数部分被丢弃<br />+t1<br />返回和t1相同值的timedelta对象<br />-t1<br />取反操作，等价于timedelta(-t1.days, -t1.seconds, -t1.microseconds)和&nbsp;t1* -1<br />abs(t)<br />绝对值，等价于： +t&nbsp;当&nbsp;t.days&nbsp;&gt;=&nbsp;0, &nbsp;-t&nbsp;当&nbsp;t.days&nbsp;&lt;&nbsp;0<br />str(t)<br />返回字符串，格式为：&nbsp;[D&nbsp;day[s],&nbsp;][H]H:MM:SS[.UUUUUU]<br />repr(t)<br />返回字符串，格式为：&nbsp;datetime.timedelta(D[,&nbsp;S[,&nbsp;U]])<br />此外，timedelta和可以和date，datetime对象进行加减操作，如：<br />Python代码&nbsp;&nbsp;</p>\r\n<pre>&gt;&gt;&gt;&nbsp;datetime.datetime.now()&nbsp;&nbsp;<br />datetime.datetime(2013,&nbsp;5,&nbsp;23,&nbsp;10,&nbsp;49,&nbsp;27,&nbsp;182057)&nbsp;&nbsp;<br />&gt;&gt;&gt;&nbsp;datetime.datetime.now()+datetime.timedelta(2)&nbsp;&nbsp;<br />datetime.datetime(2013,&nbsp;5,&nbsp;25,&nbsp;10,&nbsp;49,&nbsp;29,&nbsp;385559)&nbsp;&nbsp;</pre>\r\n<p>Python2.7新增了方法：<br />timedelta.total_seconds()用于计算秒数。等价于：(td.microseconds&nbsp;&nbsp;(td.seconds&nbsp;&nbsp;td.days&nbsp;&nbsp;24&nbsp;&nbsp;3600)&nbsp;&nbsp;106)&nbsp;/&nbsp;10*6<br />实例1：<br />\'\'\'时间d距离now()的长度，比如：1分钟前，1小时前，1月前，1年前\'\'\'<br />&nbsp;Python代码&nbsp;&nbsp;</p>\r\n<pre>#&nbsp;&nbsp;encoding=UTF-8&nbsp;--&nbsp;&nbsp;<br />import&nbsp;datetime&nbsp;&nbsp;<br />def&nbsp;timebefore(d):&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;chunks&nbsp;=&nbsp;(&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(60&nbsp;*&nbsp;60&nbsp;*&nbsp;24&nbsp;*&nbsp;365,&nbsp;u\'年\'),&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(60&nbsp;*&nbsp;60&nbsp;*&nbsp;24&nbsp;*&nbsp;30,&nbsp;u\'月\'),&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(60&nbsp;*&nbsp;60&nbsp;*&nbsp;24&nbsp;*&nbsp;7,&nbsp;u\'周\'),&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(60&nbsp;*&nbsp;60&nbsp;*&nbsp;24,&nbsp;u\'天\'),&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(60&nbsp;*&nbsp;60,&nbsp;u\'小时\'),&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(60,&nbsp;u\'分钟\'),&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;)&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#如果不是datetime类型转换后与datetime比较&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;not&nbsp;isinstance(d,&nbsp;datetime.datetime):&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;d&nbsp;=&nbsp;datetime.datetime(d.year,d.month,d.day)&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;now&nbsp;=&nbsp;datetime.datetime.now()&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;delta&nbsp;=&nbsp;now&nbsp;-&nbsp;d&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;#忽略毫秒&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;before&nbsp;=&nbsp;delta.days&nbsp;*&nbsp;24&nbsp;*&nbsp;60&nbsp;*&nbsp;60&nbsp;+&nbsp;delta.seconds&nbsp;&nbsp;#python2.7直接调用&nbsp;delta.total_seconds()&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;#刚刚过去的1分钟&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;before&nbsp;&lt;=&nbsp;60:&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;u\'刚刚\'&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;seconds,unit&nbsp;in&nbsp;chunks:&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;count&nbsp;=&nbsp;before&nbsp;//&nbsp;seconds&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;count&nbsp;!=&nbsp;0:&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;unicode(count)+unit+u\"前\"&nbsp;&nbsp;</pre>\r\n<p>&nbsp;实例2：<br />&lsquo;&rsquo;&lsquo;当前的时间上加一天或一年减一天等操作&rsquo;&lsquo;&rsquo;</p>\r\n<p>Python代码&nbsp;&nbsp;</p>\r\n<pre>#!/usr/bin/env&nbsp;python&nbsp;&nbsp;<br />#&nbsp;&nbsp;coding:utf-8&nbsp;--&nbsp;&nbsp;<br />&nbsp;&nbsp;<br />from&nbsp;datetime&nbsp;import&nbsp;datetime,timedelta&nbsp;&nbsp;<br />&nbsp;&nbsp;<br />now&nbsp;=&nbsp;datetime.now()&nbsp;&nbsp;<br />&nbsp;<br />yestoday&nbsp;=&nbsp;now&nbsp;-&nbsp;timedelta(days=1)&nbsp;&nbsp;<br />tommorow&nbsp;=&nbsp;now&nbsp;+&nbsp;timedelta(days=1)&nbsp;&nbsp;<br />&nbsp;&nbsp;<br />next_year&nbsp;=&nbsp;now&nbsp;+&nbsp;timedelta(days&nbsp;=&nbsp;365) &nbsp;</pre>','转载','2015-12-04 16:21:00',5),(30,'Java全角半角字符串转换','<pre class=\"code-java\">/**\r\n     * 半角转全角\r\n     * @param input <span class=\"code-object\">String</span>.\r\n     * @<span class=\"code-keyword\">return</span> 全角字符串.\r\n     */\r\n    <span class=\"code-keyword\">public</span> <span class=\"code-keyword\">static</span> <span class=\"code-object\">String</span> ToSBC(<span class=\"code-object\">String</span> input) {\r\n             <span class=\"code-object\">char</span> c[] = input.toCharArray();\r\n             <span class=\"code-keyword\">for</span> (<span class=\"code-object\">int</span> i = 0; i &lt; c.length; i++) {\r\n               <span class=\"code-keyword\">if</span> (c[i] == \' \') {\r\n                 c[i] = \'\\u3000\';\r\n               } <span class=\"code-keyword\">else</span> <span class=\"code-keyword\">if</span> (c[i] &lt; \'\\177\') {\r\n                 c[i] = (<span class=\"code-object\">char</span>) (c[i] + 65248);\r\n\r\n               }\r\n             }\r\n             <span class=\"code-keyword\">return</span> <span class=\"code-keyword\">new</span> <span class=\"code-object\">String</span>(c);\r\n    }\r\n\r\n    /**\r\n     * 全角转半角\r\n     * @param input <span class=\"code-object\">String</span>.\r\n     * @<span class=\"code-keyword\">return</span> 半角字符串\r\n     */\r\n    <span class=\"code-keyword\">public</span> <span class=\"code-keyword\">static</span> <span class=\"code-object\">String</span> ToDBC(<span class=\"code-object\">String</span> input) {\r\n\r\n\r\n             <span class=\"code-object\">char</span> c[] = input.toCharArray();\r\n             <span class=\"code-keyword\">for</span> (<span class=\"code-object\">int</span> i = 0; i &lt; c.length; i++) {\r\n               <span class=\"code-keyword\">if</span> (c[i] == \'\\u3000\') {\r\n                 c[i] = \' \';\r\n               } <span class=\"code-keyword\">else</span> <span class=\"code-keyword\">if</span> (c[i] &gt; \'\\uFF00\' &amp;&amp; c[i] &lt; \'\\uFF5F\') {\r\n                 c[i] = (<span class=\"code-object\">char</span>) (c[i] - 65248);\r\n\r\n               }\r\n             }\r\n        <span class=\"code-object\">String</span> returnString = <span class=\"code-keyword\">new</span> <span class=\"code-object\">String</span>(c);\r\n\r\n             <span class=\"code-keyword\">return</span> returnString;\r\n    }</pre>','努力的Coder','2015-12-04 16:33:00',12),(31,'JavaScript字符串全角半角转换','<pre class=\"code-java\"><span class=\"code-comment\">///全角空格为12288，半角空格为32\r\n</span><span class=\"code-comment\">///其他字符半角(33-126)与全角(65281-65374)的对应关系是：均相差65248\r\n</span><span class=\"code-comment\">//半角转换为全角函数\r\n</span>function ToDBC(txtstring)\r\n{\r\n<span class=\"code-keyword\">var</span> tmp = \"\";\r\n<span class=\"code-keyword\">　　for</span>(<span class=\"code-keyword\">var</span> i=0;i&lt;txtstring.length;i++)\r\n　　{\r\n<span class=\"code-keyword\">　　　if</span>(txtstring.charCodeAt(i)==32)\r\n　　　{\r\n　　　　tmp= tmp+ <span class=\"code-object\">String</span>.fromCharCode(12288);\r\n　　　}\r\n<span class=\"code-keyword\">　　　if</span>(txtstring.charCodeAt(i)&lt;127)\r\n　　　{\r\n　　　　tmp=tmp+<span class=\"code-object\">String</span>.fromCharCode(txtstring.charCodeAt(i)+65248);\r\n　　　}\r\n　　}\r\n<span class=\"code-keyword\">　return</span> tmp;\r\n}\r\n<span class=\"code-comment\">//全角转换为半角函数\r\n</span>function ToCDB(str)\r\n{\r\n<span class=\"code-keyword\">　　var</span> tmp = \"\";\r\n<span class=\"code-keyword\">　　　for</span>(<span class=\"code-keyword\">var</span> i=0;i&lt;str.length;i++)\r\n　　　{\r\n<span class=\"code-keyword\">　　　　if</span>(str.charCodeAt(i)&gt;65248&amp;&amp;str.charCodeAt(i)&lt;65375)\r\n　　　　{\r\n　　　　　tmp += <span class=\"code-object\">String</span>.fromCharCode(str.charCodeAt(i)-65248);\r\n　　　　}\r\n<span class=\"code-keyword\">　　　　else</span>\r\n　　　　{\r\n　　　　　tmp += <span class=\"code-object\">String</span>.fromCharCode(str.charCodeAt(i));\r\n　　　　}\r\n　　　}\r\n<span class=\"code-keyword\">　　return</span> tmp\r\n}</pre>','努力的Coder','2015-12-04 16:38:00',13);
/*!40000 ALTER TABLE `article` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `article_tag`
--

DROP TABLE IF EXISTS `article_tag`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `article_tag` (
  `article_id` int(11) DEFAULT NULL,
  `tag_id` int(11) DEFAULT NULL,
  KEY `article_id` (`article_id`),
  KEY `tag_id` (`tag_id`),
  CONSTRAINT `article_tag_ibfk_1` FOREIGN KEY (`article_id`) REFERENCES `article` (`id`),
  CONSTRAINT `article_tag_ibfk_2` FOREIGN KEY (`tag_id`) REFERENCES `tag` (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `article_tag`
--

LOCK TABLES `article_tag` WRITE;
/*!40000 ALTER TABLE `article_tag` DISABLE KEYS */;
/*!40000 ALTER TABLE `article_tag` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `category`
--

DROP TABLE IF EXISTS `category`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `category` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `name` varchar(32) DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=14 DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `category`
--

LOCK TABLES `category` WRITE;
/*!40000 ALTER TABLE `category` DISABLE KEYS */;
INSERT INTO `category` VALUES (5,'python'),(6,'Jinja2'),(7,'官方文档存档'),(8,'Nginx'),(10,'Solr'),(11,'数据库'),(12,'Java'),(13,'JavaScript');
/*!40000 ALTER TABLE `category` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `tag`
--

DROP TABLE IF EXISTS `tag`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `tag` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `name` varchar(16) DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `tag`
--

LOCK TABLES `tag` WRITE;
/*!40000 ALTER TABLE `tag` DISABLE KEYS */;
/*!40000 ALTER TABLE `tag` ENABLE KEYS */;
UNLOCK TABLES;
/*!40103 SET TIME_ZONE=@OLD_TIME_ZONE */;

/*!40101 SET SQL_MODE=@OLD_SQL_MODE */;
/*!40014 SET FOREIGN_KEY_CHECKS=@OLD_FOREIGN_KEY_CHECKS */;
/*!40014 SET UNIQUE_CHECKS=@OLD_UNIQUE_CHECKS */;
/*!40101 SET CHARACTER_SET_CLIENT=@OLD_CHARACTER_SET_CLIENT */;
/*!40101 SET CHARACTER_SET_RESULTS=@OLD_CHARACTER_SET_RESULTS */;
/*!40101 SET COLLATION_CONNECTION=@OLD_COLLATION_CONNECTION */;
/*!40111 SET SQL_NOTES=@OLD_SQL_NOTES */;

-- Dump completed on 2016-01-06 14:25:09
